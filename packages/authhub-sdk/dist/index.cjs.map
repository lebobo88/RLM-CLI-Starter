{"version":3,"sources":["../src/index.ts","../src/auth/types.ts","../src/auth/storage.ts","../src/auth/pkce.ts","../src/auth/redirect.ts","../src/auth/callback.ts","../src/auth/embedded.ts","../src/auth/token-manager.ts","../src/auth/state.ts","../src/auth/client.ts","../src/auth/oauth.ts","../src/ai/index.ts","../src/db/index.ts","../src/secrets/index.ts","../src/debug/breadcrumbs.ts","../src/debug/strategies/semantic-dom.ts","../src/debug/strategies/synthetic-screenshot.ts","../src/debug/strategies/aom-tree.ts","../src/debug/strategies/ast.ts","../src/debug/index.ts","../src/version.ts","../src/client.ts","../src/errors/index.ts"],"sourcesContent":["/**\r\n * AuthHub SDK\r\n *\r\n * TypeScript SDK for AuthHub - centralized authentication, database connectivity,\r\n * AI API proxy, and secrets management.\r\n *\r\n * @example\r\n * ```typescript\r\n * import { AuthHubClient } from '@authhub/sdk';\r\n *\r\n * const client = new AuthHubClient({\r\n *   baseUrl: 'https://authhub.example.com',\r\n *   apiKey: 'ak_your_api_key',\r\n * });\r\n *\r\n * // AI Chat\r\n * const response = await client.ai.chat({\r\n *   model: 'gpt-4',\r\n *   messages: [{ role: 'user', content: 'Hello!' }],\r\n * });\r\n *\r\n * // Database Query\r\n * const users = await client.db.query('SELECT * FROM users WHERE active = $1', [true]);\r\n *\r\n * // Secrets\r\n * const apiKey = await client.secrets.get('STRIPE_API_KEY');\r\n * ```\r\n *\r\n * @module @authhub/sdk\r\n */\r\n\r\n// Export types\r\nexport type {\r\n  AuthHubClientConfig,\r\n  DebugClientConfig,\r\n  ChatRole,\r\n  ChatMessage,\r\n  ChatCompletionOptions,\r\n  ChatChoice,\r\n  ChatUsage,\r\n  ChatCompletionResponse,\r\n  ChatStreamChunk,\r\n  QueryResult,\r\n  TransactionContext,\r\n  ApiErrorResponse,\r\n  // AI types\r\n  AuthHubMetadata,\r\n  AIModel,\r\n  ListModelsResponse,\r\n  ListModelsOptions,\r\n  AIUsageStats,\r\n  GetUsageOptions,\r\n  // Modality types (OpenRouter-aligned)\r\n  InputModality,\r\n  OutputModality,\r\n  ModelArchitecture,\r\n  // Image generation types (FTR-112)\r\n  ImageSize,\r\n  ImageAspectRatio,\r\n  ImageQuality,\r\n  ImageStyle,\r\n  ImageResponseFormat,\r\n  ImageOutputFormat,\r\n  ImageBackground,\r\n  ImageModeration,\r\n  ImageFidelity,\r\n  PersonGeneration,\r\n  DiffusionScheduler,\r\n  ImageStylePreset,\r\n  ImageGenerationOptions,\r\n  ImageData,\r\n  ThoughtStep,\r\n  ImageGenerationResponse,\r\n  // Embedding types (FTR-113)\r\n  EmbeddingEncodingFormat,\r\n  EmbeddingOptions,\r\n  EmbeddingData,\r\n  EmbeddingResponse,\r\n  // Transcription types (FTR-114)\r\n  TranscriptionResponseFormat,\r\n  TranscriptionFileInput,\r\n  TranscriptionOptions,\r\n  TranscriptionWord,\r\n  TranscriptionSegment,\r\n  TranscriptionResponse,\r\n  // Text-to-speech types (FTR-115)\r\n  SpeechVoice,\r\n  SpeechAudioFormat,\r\n  SpeechOptions,\r\n} from './types';\r\n\r\n// Export auth types\r\nexport type {\r\n  AuthMode,\r\n  StorageType,\r\n  AuthModuleConfig,\r\n  StoredTokenData,\r\n  TokenStorage,\r\n  AuthUser,\r\n  AuthState,\r\n  LoginResult,\r\n  RegisterResult,\r\n  RefreshResult,\r\n  PasswordResetResult,\r\n  LoginCredentials,\r\n  RegisterData,\r\n  RedirectLoginOptions,\r\n  AuthModule,\r\n  AuthErrorCode,\r\n  OAuthCallbackParams,\r\n  TokenExchangeRequest,\r\n  TokenResponse,\r\n} from './auth';\r\n\r\n// Export auth error class\r\nexport { AuthenticationError } from './auth';\r\n\r\n// Export storage implementations\r\nexport {\r\n  LocalStorageTokenStorage,\r\n  SessionStorageTokenStorage,\r\n  MemoryTokenStorage,\r\n  createTokenStorage,\r\n  isTokenExpired,\r\n  getTokenExpiresIn,\r\n  createStoredTokenData,\r\n} from './auth';\r\n\r\n// Export storage types\r\nexport type { StorageStrategyType } from './auth';\r\n\r\n// Export auth client\r\nexport { AuthClient, createAuthClient } from './auth';\r\n\r\n// Export auth client types\r\nexport type { AuthClientConfig } from './auth';\r\n\r\n// React components and hooks (AuthProvider, useAuth, useAuthHubAuth, etc.)\r\n// are NOT re-exported here to avoid pulling React into server bundles.\r\n// Import from '@authhub/sdk/auth/react' or use the auth barrel directly.\r\n\r\n// Export OAuth URL generators and callback parsing\r\nexport {\r\n  OAuthProvider,\r\n  getGoogleAuthUrl,\r\n  getGitHubAuthUrl,\r\n  getOAuthUrl,\r\n  parseOAuthCallbackResult,\r\n  hasOAuthCallback,\r\n  hasOAuthError,\r\n  getOAuthError,\r\n} from './auth';\r\n\r\n// Export OAuth types\r\nexport type {\r\n  OAuthUrlOptions,\r\n  OAuthCallbackResult,\r\n} from './auth';\r\n\r\n// Export client\r\nexport { AuthHubClient } from './client';\r\n\r\n// Export modules\r\nexport { AIModule } from './ai';\r\nexport { DBModule } from './db';\r\nexport { SecretsModule } from './secrets';\r\n\r\n// Export errors\r\nexport {\r\n  AuthHubError,\r\n  AuthError,\r\n  RateLimitError,\r\n  ValidationError,\r\n  NetworkError,\r\n  ServerError,\r\n  NotFoundError,\r\n  // AI-specific errors\r\n  AIError,\r\n} from './errors';\r\n\r\n// Export error types\r\nexport type { AIErrorCode } from './errors';\r\n\r\n// Debug module\r\nexport { DebugModule } from './debug/index';\r\nexport type {\r\n  DebugModuleConfig,\r\n  CaptureOptions,\r\n  CaptureResult,\r\n  CaptureEvent,\r\n  UserContext,\r\n  CaptureStrategyName,\r\n  Breadcrumb,\r\n  BreadcrumbType,\r\n  BreadcrumbLevel,\r\n  BreadcrumbConfig,\r\n} from './debug/types';\r\n\r\nexport type {\r\n  CaptureStrategy,\r\n  SemanticDOMCapture,\r\n  SyntheticScreenshotCapture,\r\n  AOMTreeCapture,\r\n  ASTCapture,\r\n} from './debug/strategies/index';\r\n\r\n// Export version\r\nexport { SDK_VERSION, SDK_CLIENT } from './version';\r\n","/**\n * AuthHub SDK Auth Types\n *\n * Type definitions for authentication and authorization in the SDK.\n *\n * @module @authhub/sdk/auth/types\n * @feature FTR-051\n */\n\n// ============================================================================\n// Auth Module Configuration\n// ============================================================================\n\n/**\n * Authentication mode for the SDK.\n *\n * - `redirect`: Redirects user to AuthHub's auth portal (recommended for web apps)\n * - `embedded`: Uses direct API calls for authentication (for SPAs with backend)\n */\nexport type AuthMode = 'redirect' | 'embedded';\n\n/**\n * Token storage strategy.\n *\n * - `localStorage`: Persists across browser sessions (convenient but less secure)\n * - `sessionStorage`: Clears when browser tab closes (more secure)\n * - `memory`: Clears on page refresh (most secure, least convenient)\n * - `custom`: Use a custom TokenStorage implementation\n * - `cookie`: Delegates to server-set httpOnly cookies (most secure for XSS protection)\n */\nexport type StorageType = 'localStorage' | 'sessionStorage' | 'memory' | 'custom' | 'cookie';\n\n/**\n * Configuration for the auth module.\n *\n * @example\n * ```typescript\n * const authConfig: AuthModuleConfig = {\n *   mode: 'redirect',\n *   callbackUrl: 'https://myapp.com/auth/callback',\n *   storage: 'localStorage',\n *   autoRefresh: true,\n * };\n * ```\n */\nexport interface AuthModuleConfig {\n  /**\n   * Authentication mode.\n   * @default 'redirect'\n   */\n  mode?: AuthMode;\n\n  /**\n   * URL to redirect to after authentication (for redirect mode).\n   * Must be registered in the app's allowed callback URLs.\n   */\n  callbackUrl?: string;\n\n  /**\n   * Token storage strategy.\n   * @default 'localStorage'\n   */\n  storage?: StorageType;\n\n  /**\n   * Custom token storage implementation (required if storage is 'custom').\n   */\n  customStorage?: TokenStorage;\n\n  /**\n   * Prefix for storage keys.\n   * @default 'authhub_'\n   */\n  storageKeyPrefix?: string;\n\n  /**\n   * Automatically refresh tokens before expiration.\n   * @default true\n   */\n  autoRefresh?: boolean;\n\n  /**\n   * Seconds before expiry to trigger auto-refresh.\n   * @default 60\n   */\n  refreshThreshold?: number;\n\n  /**\n   * Callback invoked when auth state changes.\n   */\n  onAuthStateChange?: (state: AuthState) => void;\n\n  /**\n   * Callback invoked when authentication fails.\n   */\n  onAuthError?: (error: AuthenticationError) => void;\n}\n\n// ============================================================================\n// Token Storage Interface\n// ============================================================================\n\n/**\n * Stored token data structure.\n */\nexport interface StoredTokenData {\n  /** Access token for API requests */\n  accessToken: string;\n  /** Refresh token for obtaining new access tokens */\n  refreshToken?: string;\n  /** Expiration timestamp (Unix epoch in milliseconds) */\n  expiresAt: number;\n  /** Token type (typically 'Bearer') */\n  tokenType: string;\n}\n\n/**\n * Interface for custom token storage implementations.\n *\n * Implement this interface to use a custom storage mechanism\n * (e.g., secure storage on mobile, encrypted IndexedDB, etc.)\n *\n * @example\n * ```typescript\n * class SecureStorage implements TokenStorage {\n *   async getTokens(): Promise<StoredTokenData | null> {\n *     const encrypted = await SecureStore.get('tokens');\n *     return encrypted ? decrypt(encrypted) : null;\n *   }\n *   async setTokens(tokens: StoredTokenData): Promise<void> {\n *     await SecureStore.set('tokens', encrypt(tokens));\n *   }\n *   async clearTokens(): Promise<void> {\n *     await SecureStore.delete('tokens');\n *   }\n * }\n * ```\n */\nexport interface TokenStorage {\n  /**\n   * Retrieve stored tokens.\n   * @returns Token data or null if not stored/expired\n   */\n  getTokens(): Promise<StoredTokenData | null> | StoredTokenData | null;\n\n  /**\n   * Store token data.\n   * @param tokens - Token data to store\n   */\n  setTokens(tokens: StoredTokenData): Promise<void> | void;\n\n  /**\n   * Clear all stored tokens.\n   */\n  clearTokens(): Promise<void> | void;\n}\n\n// ============================================================================\n// User Types\n// ============================================================================\n\n/**\n * Authenticated user information.\n *\n * @example\n * ```typescript\n * const user: AuthUser = {\n *   id: 'usr_abc123',\n *   email: 'user@example.com',\n *   name: 'John Doe',\n *   emailVerified: true,\n *   createdAt: new Date('2024-01-15'),\n * };\n * ```\n */\nexport interface AuthUser {\n  /** Unique user identifier */\n  id: string;\n  /** User's email address */\n  email: string;\n  /** User's display name */\n  name?: string;\n  /** URL to user's avatar/profile image */\n  avatarUrl?: string;\n  /** Whether the email has been verified */\n  emailVerified: boolean;\n  /** Account creation timestamp */\n  createdAt: Date;\n  /** Last update timestamp */\n  updatedAt?: Date;\n  /** Additional user metadata */\n  metadata?: Record<string, unknown>;\n}\n\n// ============================================================================\n// Auth State\n// ============================================================================\n\n/**\n * Current authentication state.\n *\n * @example\n * ```typescript\n * // Not authenticated\n * const state: AuthState = {\n *   isAuthenticated: false,\n *   isLoading: false,\n *   user: null,\n * };\n *\n * // Authenticated\n * const state: AuthState = {\n *   isAuthenticated: true,\n *   isLoading: false,\n *   user: { id: 'usr_123', email: 'user@example.com', ... },\n *   accessToken: 'eyJ...',\n * };\n * ```\n */\nexport interface AuthState {\n  /** Whether user is currently authenticated */\n  isAuthenticated: boolean;\n  /** Whether authentication state is being determined */\n  isLoading: boolean;\n  /** Authenticated user (null if not authenticated) */\n  user: AuthUser | null;\n  /** Current access token (null if not authenticated) */\n  accessToken?: string | null;\n  /** When the current token expires */\n  expiresAt?: Date | null;\n  /** Last authentication error (if any) */\n  error?: AuthenticationError | null;\n}\n\n// ============================================================================\n// Auth Results\n// ============================================================================\n\n/**\n * Result of a login operation.\n */\nexport interface LoginResult {\n  /** Whether login was successful */\n  success: boolean;\n  /** Authenticated user (if successful) */\n  user?: AuthUser;\n  /** Access token (if successful) */\n  accessToken?: string;\n  /** Refresh token (if successful) */\n  refreshToken?: string;\n  /** Token expiration timestamp */\n  expiresAt?: Date;\n  /** Error details (if failed) */\n  error?: AuthenticationError;\n}\n\n/**\n * Result of a registration operation.\n */\nexport interface RegisterResult {\n  /** Whether registration was successful */\n  success: boolean;\n  /** Newly created user (if successful) */\n  user?: AuthUser;\n  /** Whether email verification is required */\n  requiresEmailVerification?: boolean;\n  /** Error details (if failed) */\n  error?: AuthenticationError;\n}\n\n/**\n * Result of a token refresh operation.\n */\nexport interface RefreshResult {\n  /** Whether refresh was successful */\n  success: boolean;\n  /** New access token (if successful) */\n  accessToken?: string;\n  /** New refresh token (if rotated) */\n  refreshToken?: string;\n  /** New expiration timestamp */\n  expiresAt?: Date;\n  /** Error details (if failed) */\n  error?: AuthenticationError;\n}\n\n/**\n * Result of a password reset request.\n */\nexport interface PasswordResetResult {\n  /** Whether request was accepted */\n  success: boolean;\n  /** Message to display to user */\n  message?: string;\n  /** Error details (if failed) */\n  error?: AuthenticationError;\n}\n\n// ============================================================================\n// Auth Module Interface\n// ============================================================================\n\n/**\n * Login credentials for embedded mode.\n */\nexport interface LoginCredentials {\n  /** User's email address */\n  email: string;\n  /** User's password */\n  password: string;\n}\n\n/**\n * Registration data for embedded mode.\n */\nexport interface RegisterData {\n  /** User's email address */\n  email: string;\n  /** User's password */\n  password: string;\n  /** User's display name */\n  name?: string;\n}\n\n/**\n * Options for initiating redirect-based login.\n */\nexport interface RedirectLoginOptions {\n  /** State parameter for CSRF protection (auto-generated if not provided) */\n  state?: string;\n  /** URL to redirect to after login (overrides callbackUrl) */\n  redirectTo?: string;\n}\n\n/**\n * Auth module interface for SDK integration.\n *\n * @example\n * ```typescript\n * // Redirect mode\n * await client.auth.login(); // Redirects to auth portal\n *\n * // Embedded mode\n * const result = await client.auth.login({ email, password });\n *\n * // Check auth state\n * const { isAuthenticated, user } = client.auth.getState();\n *\n * // Logout\n * await client.auth.logout();\n * ```\n */\nexport interface AuthModule {\n  /**\n   * Current authentication state.\n   */\n  getState(): AuthState;\n\n  /**\n   * Subscribe to auth state changes.\n   * @param callback - Function called when auth state changes\n   * @returns Unsubscribe function\n   */\n  onStateChange(callback: (state: AuthState) => void): () => void;\n\n  /**\n   * Initiate login flow.\n   *\n   * In redirect mode: Redirects to AuthHub auth portal\n   * In embedded mode: Authenticates with credentials\n   *\n   * @param credentials - Login credentials (required for embedded mode)\n   * @param options - Login options (for redirect mode)\n   */\n  login(\n    credentials?: LoginCredentials,\n    options?: RedirectLoginOptions\n  ): Promise<LoginResult | void>;\n\n  /**\n   * Register a new user (embedded mode only).\n   *\n   * @param data - Registration data\n   */\n  register(data: RegisterData): Promise<RegisterResult>;\n\n  /**\n   * Log out the current user.\n   * Clears tokens and revokes session on server.\n   */\n  logout(): Promise<void>;\n\n  /**\n   * Handle OAuth callback (redirect mode only).\n   * Call this on your callback page to complete authentication.\n   *\n   * @param url - Current URL with OAuth parameters (uses window.location if not provided)\n   */\n  handleCallback(url?: string): Promise<LoginResult>;\n\n  /**\n   * Refresh the current access token.\n   * Called automatically if autoRefresh is enabled.\n   */\n  refreshToken(): Promise<RefreshResult>;\n\n  /**\n   * Request a password reset email.\n   *\n   * @param email - Email address to send reset link to\n   */\n  requestPasswordReset(email: string): Promise<PasswordResetResult>;\n\n  /**\n   * Reset password with token from email.\n   *\n   * @param token - Reset token from email\n   * @param newPassword - New password to set\n   */\n  resetPassword(token: string, newPassword: string): Promise<PasswordResetResult>;\n\n  /**\n   * Get a valid access token for API requests.\n   * Automatically refreshes if expired.\n   *\n   * @returns Access token or null if not authenticated\n   */\n  getAccessToken(): Promise<string | null>;\n\n  /**\n   * Check if user has a valid session.\n   * Verifies token with server.\n   */\n  validateSession(): Promise<boolean>;\n}\n\n// ============================================================================\n// Auth Errors\n// ============================================================================\n\n/**\n * Error codes for authentication failures.\n */\nexport type AuthErrorCode =\n  | 'INVALID_CREDENTIALS'\n  | 'EMAIL_NOT_VERIFIED'\n  | 'ACCOUNT_LOCKED'\n  | 'ACCOUNT_DISABLED'\n  | 'SESSION_EXPIRED'\n  | 'TOKEN_EXPIRED'\n  | 'TOKEN_INVALID'\n  | 'TOKEN_REUSE_DETECTED'\n  | 'MAX_SESSIONS_EXCEEDED'\n  | 'PASSWORD_TOO_WEAK'\n  | 'EMAIL_ALREADY_EXISTS'\n  | 'INVALID_RESET_TOKEN'\n  | 'RESET_TOKEN_EXPIRED'\n  | 'NETWORK_ERROR'\n  | 'SERVER_ERROR'\n  | 'UNKNOWN_ERROR';\n\n/**\n * Authentication error with detailed information.\n *\n * @example\n * ```typescript\n * try {\n *   await client.auth.login({ email, password });\n * } catch (error) {\n *   if (error instanceof AuthenticationError) {\n *     switch (error.code) {\n *       case 'INVALID_CREDENTIALS':\n *         showError('Invalid email or password');\n *         break;\n *       case 'EMAIL_NOT_VERIFIED':\n *         showError('Please verify your email first');\n *         break;\n *       case 'ACCOUNT_LOCKED':\n *         showError('Account locked. Try again later.');\n *         break;\n *     }\n *   }\n * }\n * ```\n */\nexport class AuthenticationError extends Error {\n  /** Error code for programmatic handling */\n  readonly code: AuthErrorCode;\n\n  /** HTTP status code (if applicable) */\n  readonly statusCode: number | undefined;\n\n  /** Additional error details */\n  readonly details: Record<string, unknown> | undefined;\n\n  /** Whether this error is transient and worth retrying */\n  readonly isRetryable: boolean;\n\n  constructor(\n    message: string,\n    code: AuthErrorCode,\n    statusCode?: number,\n    details?: Record<string, unknown>\n  ) {\n    super(message);\n    this.name = 'AuthenticationError';\n    this.code = code;\n    this.statusCode = statusCode;\n    this.details = details;\n\n    // Determine if error is retryable\n    this.isRetryable = [\n      'NETWORK_ERROR',\n      'SERVER_ERROR',\n      'TOKEN_EXPIRED',\n    ].includes(code);\n\n    // Maintains proper stack trace\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, AuthenticationError);\n    }\n  }\n\n  /**\n   * Get a user-friendly error message.\n   */\n  get userMessage(): string {\n    switch (this.code) {\n      case 'INVALID_CREDENTIALS':\n        return 'Invalid email or password. Please try again.';\n      case 'EMAIL_NOT_VERIFIED':\n        return 'Please verify your email address before signing in.';\n      case 'ACCOUNT_LOCKED':\n        return 'Your account has been temporarily locked. Please try again later.';\n      case 'ACCOUNT_DISABLED':\n        return 'Your account has been disabled. Please contact support.';\n      case 'SESSION_EXPIRED':\n        return 'Your session has expired. Please sign in again.';\n      case 'TOKEN_EXPIRED':\n        return 'Your session has expired. Please sign in again.';\n      case 'TOKEN_INVALID':\n        return 'Invalid authentication. Please sign in again.';\n      case 'TOKEN_REUSE_DETECTED':\n        return 'Security alert: Session may be compromised. Please sign in again.';\n      case 'MAX_SESSIONS_EXCEEDED':\n        return 'Maximum sessions exceeded. Please sign out from another device.';\n      case 'PASSWORD_TOO_WEAK':\n        return 'Password is too weak. Please use a stronger password.';\n      case 'EMAIL_ALREADY_EXISTS':\n        return 'An account with this email already exists.';\n      case 'INVALID_RESET_TOKEN':\n        return 'Invalid password reset link. Please request a new one.';\n      case 'RESET_TOKEN_EXPIRED':\n        return 'Password reset link has expired. Please request a new one.';\n      case 'NETWORK_ERROR':\n        return 'Network error. Please check your connection and try again.';\n      case 'SERVER_ERROR':\n        return 'Server error. Please try again later.';\n      default:\n        return 'An unexpected error occurred. Please try again.';\n    }\n  }\n\n  /**\n   * Get troubleshooting suggestions.\n   */\n  get suggestion(): string {\n    switch (this.code) {\n      case 'INVALID_CREDENTIALS':\n        return 'Double-check your email and password. Use \"Forgot Password\" if needed.';\n      case 'EMAIL_NOT_VERIFIED':\n        return 'Check your email inbox (and spam folder) for the verification link.';\n      case 'ACCOUNT_LOCKED':\n        return 'Wait 15 minutes or contact support to unlock your account.';\n      case 'TOKEN_REUSE_DETECTED':\n        return 'For security, sign out from all devices and change your password.';\n      case 'PASSWORD_TOO_WEAK':\n        return 'Use at least 8 characters with uppercase, lowercase, number, and special character.';\n      default:\n        return '';\n    }\n  }\n}\n\n// ============================================================================\n// OAuth Types (for redirect mode)\n// ============================================================================\n\n/**\n * OAuth callback parameters.\n */\nexport interface OAuthCallbackParams {\n  /** Authorization code from OAuth flow */\n  code?: string;\n  /** State parameter for CSRF validation */\n  state?: string;\n  /** Error code (if authorization failed) */\n  error?: string;\n  /** Error description */\n  error_description?: string;\n}\n\n/**\n * Token exchange request (internal use).\n */\nexport interface TokenExchangeRequest {\n  /** Authorization code */\n  code: string;\n  /** Redirect URI used in authorization */\n  redirect_uri: string;\n  /** Grant type (always 'authorization_code') */\n  grant_type: 'authorization_code';\n}\n\n/**\n * Token response from OAuth token endpoint.\n */\nexport interface TokenResponse {\n  /** Access token for API requests */\n  access_token: string;\n  /** Token type (typically 'Bearer') */\n  token_type: string;\n  /** Token validity in seconds */\n  expires_in: number;\n  /** Refresh token for obtaining new access tokens */\n  refresh_token?: string;\n  /** Granted scopes */\n  scope?: string;\n}\n","/**\n * AuthHub SDK Token Storage Implementations\n *\n * Provides storage strategies for persisting authentication tokens.\n *\n * @module @authhub/sdk/auth/storage\n * @feature FTR-051\n */\n\nimport type { TokenStorage, StoredTokenData } from './types';\n\n// ============================================================================\n// Constants\n// ============================================================================\n\n/** Default storage key prefix */\nconst DEFAULT_KEY_PREFIX = 'authhub_';\n\n/** Storage key suffix for token data */\nconst TOKENS_KEY = 'tokens';\n\n// ============================================================================\n// Base Storage Class\n// ============================================================================\n\n/**\n * Base class for browser storage implementations.\n * Provides common functionality for localStorage and sessionStorage.\n *\n * @internal\n */\nabstract class BrowserTokenStorage implements TokenStorage {\n  protected readonly keyPrefix: string;\n  protected abstract readonly storage: Storage | null;\n\n  constructor(keyPrefix: string = DEFAULT_KEY_PREFIX) {\n    this.keyPrefix = keyPrefix;\n  }\n\n  /**\n   * Get the full storage key for tokens.\n   */\n  protected get storageKey(): string {\n    return `${this.keyPrefix}${TOKENS_KEY}`;\n  }\n\n  /**\n   * Check if storage is available.\n   */\n  protected isStorageAvailable(): boolean {\n    if (!this.storage) {\n      return false;\n    }\n\n    try {\n      const testKey = `${this.keyPrefix}test`;\n      this.storage.setItem(testKey, 'test');\n      this.storage.removeItem(testKey);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Retrieve stored tokens.\n   * Returns null if tokens don't exist, are expired, or storage is unavailable.\n   */\n  getTokens(): StoredTokenData | null {\n    if (!this.isStorageAvailable()) {\n      return null;\n    }\n\n    try {\n      const stored = this.storage!.getItem(this.storageKey);\n      if (!stored) {\n        return null;\n      }\n\n      const data = JSON.parse(stored) as StoredTokenData;\n\n      // Check if token is expired\n      if (this.isExpired(data.expiresAt)) {\n        this.clearTokens();\n        return null;\n      }\n\n      return data;\n    } catch {\n      // Invalid JSON or other error - clear corrupted data\n      this.clearTokens();\n      return null;\n    }\n  }\n\n  /**\n   * Store token data.\n   *\n   * @param tokens - Token data to store\n   * @throws {Error} If storage quota is exceeded\n   */\n  setTokens(tokens: StoredTokenData): void {\n    if (!this.isStorageAvailable()) {\n      console.warn('AuthHub: Storage not available, tokens will not persist');\n      return;\n    }\n\n    try {\n      const serialized = JSON.stringify(tokens);\n      this.storage!.setItem(this.storageKey, serialized);\n    } catch (error) {\n      // Handle quota exceeded error\n      if (error instanceof Error && error.name === 'QuotaExceededError') {\n        throw new Error('Storage quota exceeded. Please clear some data and try again.');\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Clear all stored tokens.\n   */\n  clearTokens(): void {\n    if (!this.isStorageAvailable()) {\n      return;\n    }\n\n    try {\n      this.storage!.removeItem(this.storageKey);\n    } catch {\n      // Ignore errors when clearing\n    }\n  }\n\n  /**\n   * Check if a timestamp is expired.\n   *\n   * @param expiresAt - Expiration timestamp in milliseconds\n   * @returns True if expired\n   */\n  protected isExpired(expiresAt: number): boolean {\n    return Date.now() >= expiresAt;\n  }\n}\n\n// ============================================================================\n// LocalStorage Implementation\n// ============================================================================\n\n/**\n * Token storage using browser localStorage.\n *\n * Tokens persist across browser sessions until explicitly cleared\n * or until they expire.\n *\n * **Security Note:** localStorage is accessible to any JavaScript running\n * on the same origin. For high-security applications, consider using\n * sessionStorage or memory storage.\n *\n * @example\n * ```typescript\n * const storage = new LocalStorageTokenStorage('myapp_');\n *\n * // Store tokens\n * storage.setTokens({\n *   accessToken: 'eyJ...',\n *   refreshToken: 'dGhp...',\n *   expiresAt: Date.now() + 3600000,\n *   tokenType: 'Bearer',\n * });\n *\n * // Retrieve tokens\n * const tokens = storage.getTokens();\n * if (tokens) {\n *   console.log('Access token:', tokens.accessToken);\n * }\n *\n * // Clear tokens on logout\n * storage.clearTokens();\n * ```\n */\nexport class LocalStorageTokenStorage extends BrowserTokenStorage {\n  protected readonly storage: Storage | null;\n\n  /**\n   * Create a new localStorage token storage.\n   *\n   * @param keyPrefix - Prefix for storage keys (default: 'authhub_')\n   */\n  constructor(keyPrefix: string = DEFAULT_KEY_PREFIX) {\n    super(keyPrefix);\n    this.storage = typeof window !== 'undefined' ? window.localStorage : null;\n  }\n}\n\n// ============================================================================\n// SessionStorage Implementation\n// ============================================================================\n\n/**\n * Token storage using browser sessionStorage.\n *\n * Tokens persist only within the current browser tab/window session.\n * When the tab is closed, tokens are automatically cleared.\n *\n * **Security Note:** sessionStorage provides better security than localStorage\n * as tokens don't persist across sessions. However, it's still accessible\n * to JavaScript on the same origin.\n *\n * @example\n * ```typescript\n * const storage = new SessionStorageTokenStorage();\n *\n * // Store tokens - cleared when tab closes\n * storage.setTokens({\n *   accessToken: 'eyJ...',\n *   expiresAt: Date.now() + 3600000,\n *   tokenType: 'Bearer',\n * });\n * ```\n */\nexport class SessionStorageTokenStorage extends BrowserTokenStorage {\n  protected readonly storage: Storage | null;\n\n  /**\n   * Create a new sessionStorage token storage.\n   *\n   * @param keyPrefix - Prefix for storage keys (default: 'authhub_')\n   */\n  constructor(keyPrefix: string = DEFAULT_KEY_PREFIX) {\n    super(keyPrefix);\n    this.storage = typeof window !== 'undefined' ? window.sessionStorage : null;\n  }\n}\n\n// ============================================================================\n// Memory Storage Implementation\n// ============================================================================\n\n/**\n * Token storage in memory only.\n *\n * Tokens are stored in a JavaScript variable and cleared when the page\n * is refreshed or the tab is closed. This provides the highest security\n * but requires re-authentication on every page load.\n *\n * **Use Cases:**\n * - High-security applications where persistence is not acceptable\n * - Server-side rendering (SSR) environments\n * - Testing and development\n *\n * @example\n * ```typescript\n * const storage = new MemoryTokenStorage();\n *\n * // Store tokens - cleared on page refresh\n * storage.setTokens({\n *   accessToken: 'eyJ...',\n *   expiresAt: Date.now() + 3600000,\n *   tokenType: 'Bearer',\n * });\n *\n * // Later, check if still authenticated\n * const tokens = storage.getTokens();\n * if (!tokens) {\n *   // Re-authenticate user\n * }\n * ```\n */\nexport class MemoryTokenStorage implements TokenStorage {\n  private tokens: StoredTokenData | null = null;\n\n  /**\n   * Retrieve stored tokens.\n   * Returns null if tokens don't exist or are expired.\n   */\n  getTokens(): StoredTokenData | null {\n    if (!this.tokens) {\n      return null;\n    }\n\n    // Check if token is expired\n    if (Date.now() >= this.tokens.expiresAt) {\n      this.clearTokens();\n      return null;\n    }\n\n    return this.tokens;\n  }\n\n  /**\n   * Store token data in memory.\n   *\n   * @param tokens - Token data to store\n   */\n  setTokens(tokens: StoredTokenData): void {\n    this.tokens = { ...tokens };\n  }\n\n  /**\n   * Clear stored tokens from memory.\n   */\n  clearTokens(): void {\n    this.tokens = null;\n  }\n}\n\n// ============================================================================\n// Cookie Token Storage Implementation\n// ============================================================================\n\n/**\n * Cookie-based token storage.\n *\n * Tokens are managed server-side via httpOnly cookies. This class tracks\n * authentication state locally but delegates actual token storage to\n * server-set httpOnly cookies, providing XSS protection.\n *\n * **Security Benefits:**\n * - Tokens are inaccessible to JavaScript (XSS protection)\n * - Browser automatically includes cookies in requests\n * - Server controls token lifecycle\n *\n * @example\n * ```typescript\n * const storage = new CookieTokenStorage();\n *\n * // After server sets cookies, update local state\n * storage.setTokens({\n *   accessToken: '', // Actual token is in httpOnly cookie\n *   expiresAt: Date.now() + 900000, // 15 minutes\n *   tokenType: 'Bearer',\n * });\n *\n * // Check authentication state (for UI purposes)\n * if (storage.isAuthenticated()) {\n *   console.log('User is authenticated');\n * }\n *\n * // Clear local state (server handles cookie clearing)\n * storage.clearTokens();\n * ```\n *\n * @task TASK-500\n * @feature FTR-109\n */\nexport class CookieTokenStorage implements TokenStorage {\n  private _isAuthenticated: boolean = false;\n  private _expiresAt: number | null = null;\n\n  /**\n   * Get tokens - returns metadata only since actual tokens are in httpOnly cookies.\n   * Auth state is determined by server response, not local storage.\n   *\n   * @returns Token data with empty accessToken (actual token in cookie) or null if not authenticated/expired\n   */\n  getTokens(): StoredTokenData | null {\n    // Cannot read httpOnly cookies from JS - this is by design\n    // Return cached state for UI purposes only\n    if (this._isAuthenticated && this._expiresAt && Date.now() < this._expiresAt) {\n      return {\n        accessToken: '', // Placeholder - actual token in cookie\n        expiresAt: this._expiresAt,\n        tokenType: 'Bearer',\n      };\n    }\n    return null;\n  }\n\n  /**\n   * Set tokens - only caches metadata, actual tokens are in httpOnly cookies.\n   * Call this after the server has set the httpOnly cookies.\n   *\n   * @param tokens - Token metadata (accessToken value is ignored, stored in cookie)\n   */\n  setTokens(tokens: StoredTokenData): void {\n    this._isAuthenticated = true;\n    this._expiresAt = tokens.expiresAt;\n  }\n\n  /**\n   * Clear tokens - clears local authentication state.\n   * Note: Actual cookie clearing must be done by the server via Set-Cookie with maxAge=0.\n   */\n  clearTokens(): void {\n    this._isAuthenticated = false;\n    this._expiresAt = null;\n  }\n\n  /**\n   * Check if user is authenticated based on cached state.\n   * Note: For true authentication status, check with the server.\n   *\n   * @returns True if authenticated and not expired\n   */\n  isAuthenticated(): boolean {\n    if (!this._isAuthenticated || !this._expiresAt) {\n      return false;\n    }\n    // Check if token is expired\n    if (Date.now() >= this._expiresAt) {\n      this._isAuthenticated = false;\n      this._expiresAt = null;\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Check if this storage uses cookie mode.\n   * Useful for determining request configuration (credentials: 'include').\n   *\n   * @returns Always true for CookieTokenStorage\n   */\n  isCookieMode(): boolean {\n    return true;\n  }\n}\n\n// ============================================================================\n// Storage Factory\n// ============================================================================\n\n/**\n * Storage type for the factory function.\n */\nexport type StorageStrategyType = 'localStorage' | 'sessionStorage' | 'memory' | 'cookie';\n\n/**\n * Create a token storage instance based on the specified type.\n *\n * @param type - Storage type to create\n * @param keyPrefix - Optional key prefix for browser storage\n * @returns TokenStorage instance\n *\n * @example\n * ```typescript\n * // Create localStorage storage\n * const storage = createTokenStorage('localStorage');\n *\n * // Create sessionStorage with custom prefix\n * const storage = createTokenStorage('sessionStorage', 'myapp_');\n *\n * // Create memory storage\n * const storage = createTokenStorage('memory');\n * ```\n */\nexport function createTokenStorage(\n  type: StorageStrategyType,\n  keyPrefix: string = DEFAULT_KEY_PREFIX\n): TokenStorage {\n  switch (type) {\n    case 'localStorage':\n      return new LocalStorageTokenStorage(keyPrefix);\n    case 'sessionStorage':\n      return new SessionStorageTokenStorage(keyPrefix);\n    case 'memory':\n      return new MemoryTokenStorage();\n    case 'cookie':\n      return new CookieTokenStorage();\n    default:\n      throw new Error(`Unknown storage type: ${type}`);\n  }\n}\n\n// ============================================================================\n// Storage Utilities\n// ============================================================================\n\n/**\n * Check if the token data is expired or about to expire.\n *\n * @param tokens - Token data to check\n * @param thresholdSeconds - Consider expired if within this many seconds\n * @returns True if expired or expiring within threshold\n *\n * @example\n * ```typescript\n * const tokens = storage.getTokens();\n * if (tokens && isTokenExpired(tokens, 60)) {\n *   // Token expires within 60 seconds, refresh it\n *   await refreshToken();\n * }\n * ```\n */\nexport function isTokenExpired(\n  tokens: StoredTokenData,\n  thresholdSeconds: number = 0\n): boolean {\n  const thresholdMs = thresholdSeconds * 1000;\n  return Date.now() + thresholdMs >= tokens.expiresAt;\n}\n\n/**\n * Calculate the time remaining until token expiration.\n *\n * @param tokens - Token data to check\n * @returns Milliseconds until expiration (negative if expired)\n *\n * @example\n * ```typescript\n * const tokens = storage.getTokens();\n * if (tokens) {\n *   const remaining = getTokenExpiresIn(tokens);\n *   console.log(`Token expires in ${Math.floor(remaining / 1000)} seconds`);\n * }\n * ```\n */\nexport function getTokenExpiresIn(tokens: StoredTokenData): number {\n  return tokens.expiresAt - Date.now();\n}\n\n/**\n * Create a StoredTokenData object from a token response.\n *\n * @param accessToken - Access token string\n * @param expiresIn - Token validity in seconds\n * @param refreshToken - Optional refresh token\n * @param tokenType - Token type (default: 'Bearer')\n * @returns StoredTokenData object ready for storage\n *\n * @example\n * ```typescript\n * // From API response\n * const response = await api.post('/auth/token', { ... });\n * const tokenData = createStoredTokenData(\n *   response.access_token,\n *   response.expires_in,\n *   response.refresh_token\n * );\n * storage.setTokens(tokenData);\n * ```\n */\nexport function createStoredTokenData(\n  accessToken: string,\n  expiresIn: number,\n  refreshToken?: string,\n  tokenType: string = 'Bearer'\n): StoredTokenData {\n  const data: StoredTokenData = {\n    accessToken,\n    expiresAt: Date.now() + expiresIn * 1000,\n    tokenType,\n  };\n\n  // Only include refreshToken if provided\n  if (refreshToken !== undefined) {\n    data.refreshToken = refreshToken;\n  }\n\n  return data;\n}\n","/**\n * AuthHub SDK PKCE Utilities\n *\n * Proof Key for Code Exchange (PKCE) implementation for secure OAuth flows.\n * RFC 7636: https://tools.ietf.org/html/rfc7636\n *\n * @module @authhub/sdk/auth/pkce\n * @feature FTR-051\n */\n\n// ============================================================================\n// Constants\n// ============================================================================\n\n/** Length of the code verifier in bytes (recommended: 32-96 bytes) */\nconst CODE_VERIFIER_LENGTH = 64;\n\n/** Characters used for base64url encoding */\nconst BASE64URL_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_';\n\n// ============================================================================\n// Types\n// ============================================================================\n\n/**\n * PKCE code pair containing verifier and challenge.\n */\nexport interface PKCECodePair {\n  /** Code verifier - random string sent with token request */\n  codeVerifier: string;\n  /** Code challenge - SHA256 hash of verifier, sent with authorization request */\n  codeChallenge: string;\n  /** Challenge method (always 'S256' for this implementation) */\n  codeChallengeMethod: 'S256';\n}\n\n// ============================================================================\n// Crypto Utilities\n// ============================================================================\n\n/**\n * Generate cryptographically secure random bytes.\n *\n * @param length - Number of bytes to generate\n * @returns Uint8Array of random bytes\n * @throws {Error} If crypto API is not available\n */\nfunction getRandomBytes(length: number): Uint8Array {\n  if (typeof crypto !== 'undefined' && crypto.getRandomValues) {\n    const bytes = new Uint8Array(length);\n    crypto.getRandomValues(bytes);\n    return bytes;\n  }\n\n  throw new Error(\n    'Crypto API not available. PKCE requires a secure random number generator.'\n  );\n}\n\n/**\n * Compute SHA-256 hash of a string.\n *\n * @param input - String to hash\n * @returns Promise resolving to Uint8Array hash\n * @throws {Error} If SubtleCrypto is not available\n */\nasync function sha256(input: string): Promise<Uint8Array> {\n  if (typeof crypto !== 'undefined' && crypto.subtle) {\n    const encoder = new TextEncoder();\n    const data = encoder.encode(input);\n    const hashBuffer = await crypto.subtle.digest('SHA-256', data);\n    return new Uint8Array(hashBuffer);\n  }\n\n  throw new Error(\n    'SubtleCrypto API not available. PKCE requires SHA-256 hashing capability.'\n  );\n}\n\n/**\n * Encode bytes to base64url string (URL-safe base64 without padding).\n *\n * Uses btoa in browser environments, with a manual fallback for Node.js.\n *\n * @param bytes - Bytes to encode\n * @returns Base64url encoded string\n */\nfunction base64urlEncode(bytes: Uint8Array): string {\n  // Use btoa if available (browsers)\n  if (typeof btoa !== 'undefined') {\n    const binaryString = String.fromCharCode(...bytes);\n    const base64 = btoa(binaryString);\n    // Convert standard base64 to base64url\n    return base64.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=+$/, '');\n  }\n\n  // Node.js fallback using Buffer\n  if (typeof Buffer !== 'undefined') {\n    return Buffer.from(bytes)\n      .toString('base64')\n      .replace(/\\+/g, '-')\n      .replace(/\\//g, '_')\n      .replace(/=+$/, '');\n  }\n\n  // Manual encoding as last resort\n  let result = '';\n  const len = bytes.length;\n\n  for (let i = 0; i < len; i += 3) {\n    const b1 = bytes[i] ?? 0;\n    const b2 = bytes[i + 1] ?? 0;\n    const b3 = bytes[i + 2] ?? 0;\n\n    result += BASE64URL_CHARS[b1 >> 2];\n    result += BASE64URL_CHARS[((b1 & 3) << 4) | (b2 >> 4)];\n\n    if (i + 1 < len) {\n      result += BASE64URL_CHARS[((b2 & 15) << 2) | (b3 >> 6)];\n    }\n\n    if (i + 2 < len) {\n      result += BASE64URL_CHARS[b3 & 63];\n    }\n  }\n\n  return result;\n}\n\n// ============================================================================\n// PKCE Functions\n// ============================================================================\n\n/**\n * Generate a cryptographically random code verifier.\n *\n * The code verifier is a high-entropy random string between 43-128 characters\n * using unreserved characters (A-Z, a-z, 0-9, -, ., _, ~).\n *\n * @returns Code verifier string\n *\n * @example\n * ```typescript\n * const verifier = generateCodeVerifier();\n * // Returns something like: \"dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk\"\n * ```\n */\nexport function generateCodeVerifier(): string {\n  const randomBytes = getRandomBytes(CODE_VERIFIER_LENGTH);\n  return base64urlEncode(randomBytes);\n}\n\n/**\n * Generate the code challenge from a code verifier using SHA-256.\n *\n * @param verifier - The code verifier string\n * @returns Promise resolving to the code challenge\n *\n * @example\n * ```typescript\n * const verifier = generateCodeVerifier();\n * const challenge = await generateCodeChallenge(verifier);\n * // challenge is the base64url-encoded SHA-256 hash of verifier\n * ```\n */\nexport async function generateCodeChallenge(verifier: string): Promise<string> {\n  const hash = await sha256(verifier);\n  return base64urlEncode(hash);\n}\n\n/**\n * Generate a complete PKCE code pair (verifier + challenge).\n *\n * @returns Promise resolving to PKCECodePair\n *\n * @example\n * ```typescript\n * const pkce = await generatePKCECodePair();\n *\n * // Store verifier securely (e.g., sessionStorage)\n * sessionStorage.setItem('pkce_verifier', pkce.codeVerifier);\n *\n * // Send challenge with authorization request\n * const authUrl = new URL('https://auth.example.com/authorize');\n * authUrl.searchParams.set('code_challenge', pkce.codeChallenge);\n * authUrl.searchParams.set('code_challenge_method', pkce.codeChallengeMethod);\n * ```\n */\nexport async function generatePKCECodePair(): Promise<PKCECodePair> {\n  const codeVerifier = generateCodeVerifier();\n  const codeChallenge = await generateCodeChallenge(codeVerifier);\n\n  return {\n    codeVerifier,\n    codeChallenge,\n    codeChallengeMethod: 'S256',\n  };\n}\n\n// ============================================================================\n// State Parameter\n// ============================================================================\n\n/**\n * Generate a cryptographically random state parameter.\n *\n * The state parameter is used for CSRF protection in OAuth flows.\n * It should be stored before redirect and validated on callback.\n *\n * @param length - Length of random bytes (default: 32)\n * @returns Random state string\n *\n * @example\n * ```typescript\n * const state = generateState();\n * sessionStorage.setItem('oauth_state', state);\n *\n * // Include state in authorization URL\n * authUrl.searchParams.set('state', state);\n *\n * // On callback, validate state matches\n * const callbackState = new URLSearchParams(location.search).get('state');\n * if (callbackState !== sessionStorage.getItem('oauth_state')) {\n *   throw new Error('Invalid state parameter');\n * }\n * ```\n */\nexport function generateState(length: number = 32): string {\n  const randomBytes = getRandomBytes(length);\n  return base64urlEncode(randomBytes);\n}\n\n// ============================================================================\n// Storage Keys\n// ============================================================================\n\n/** Storage key for PKCE code verifier */\nexport const PKCE_VERIFIER_KEY = 'authhub_pkce_verifier';\n\n/** Storage key for OAuth state parameter */\nexport const OAUTH_STATE_KEY = 'authhub_oauth_state';\n\n/** Storage key for redirect target after auth */\nexport const REDIRECT_TARGET_KEY = 'authhub_redirect_target';\n\n/** Storage key for timestamp to prevent replay attacks */\nexport const PKCE_TIMESTAMP_KEY = 'authhub_pkce_timestamp';\n\n/** Maximum age for PKCE data in milliseconds (10 minutes) */\nexport const PKCE_MAX_AGE_MS = 10 * 60 * 1000;\n\n// ============================================================================\n// Session Storage Helpers\n// ============================================================================\n\n/**\n * Store PKCE data in sessionStorage for callback validation.\n *\n * @param codeVerifier - PKCE code verifier\n * @param state - OAuth state parameter\n * @param redirectTarget - Optional URL to redirect to after auth\n *\n * @example\n * ```typescript\n * const pkce = await generatePKCECodePair();\n * const state = generateState();\n *\n * storePKCEData(pkce.codeVerifier, state, '/dashboard');\n *\n * // Later, on callback:\n * const { codeVerifier, state, redirectTarget } = retrievePKCEData();\n * ```\n */\nexport function storePKCEData(\n  codeVerifier: string,\n  state: string,\n  redirectTarget?: string\n): void {\n  if (typeof sessionStorage === 'undefined') {\n    console.warn('AuthHub: sessionStorage not available, PKCE data will not persist');\n    return;\n  }\n\n  sessionStorage.setItem(PKCE_VERIFIER_KEY, codeVerifier);\n  sessionStorage.setItem(OAUTH_STATE_KEY, state);\n  sessionStorage.setItem(PKCE_TIMESTAMP_KEY, Date.now().toString());\n\n  if (redirectTarget) {\n    sessionStorage.setItem(REDIRECT_TARGET_KEY, redirectTarget);\n  }\n}\n\n/**\n * Retrieve stored PKCE data from sessionStorage.\n *\n * Returns null values if data has expired (older than PKCE_MAX_AGE_MS).\n * This prevents replay attacks using stale PKCE data.\n *\n * @returns Object with codeVerifier, state, timestamp, and optional redirectTarget\n */\nexport function retrievePKCEData(): {\n  codeVerifier: string | null;\n  state: string | null;\n  redirectTarget: string | null;\n  timestamp: number | null;\n  isExpired: boolean;\n} {\n  if (typeof sessionStorage === 'undefined') {\n    return { codeVerifier: null, state: null, redirectTarget: null, timestamp: null, isExpired: true };\n  }\n\n  const timestampStr = sessionStorage.getItem(PKCE_TIMESTAMP_KEY);\n  const timestamp = timestampStr ? parseInt(timestampStr, 10) : null;\n  const isExpired = timestamp ? Date.now() - timestamp > PKCE_MAX_AGE_MS : true;\n\n  // If expired, clear the data and return null values\n  if (isExpired && timestamp !== null) {\n    clearPKCEData();\n    return { codeVerifier: null, state: null, redirectTarget: null, timestamp, isExpired: true };\n  }\n\n  return {\n    codeVerifier: sessionStorage.getItem(PKCE_VERIFIER_KEY),\n    state: sessionStorage.getItem(OAUTH_STATE_KEY),\n    redirectTarget: sessionStorage.getItem(REDIRECT_TARGET_KEY),\n    timestamp,\n    isExpired,\n  };\n}\n\n/**\n * Clear stored PKCE data from sessionStorage.\n */\nexport function clearPKCEData(): void {\n  if (typeof sessionStorage === 'undefined') {\n    return;\n  }\n\n  sessionStorage.removeItem(PKCE_VERIFIER_KEY);\n  sessionStorage.removeItem(OAUTH_STATE_KEY);\n  sessionStorage.removeItem(REDIRECT_TARGET_KEY);\n  sessionStorage.removeItem(PKCE_TIMESTAMP_KEY);\n}\n","/**\n * AuthHub SDK Redirect Mode Authentication\n *\n * Implements OAuth 2.0 authorization code flow with PKCE for secure\n * redirect-based authentication.\n *\n * @module @authhub/sdk/auth/redirect\n * @feature FTR-051\n */\n\nimport type { RedirectLoginOptions, TokenStorage } from './types';\nimport {\n  generatePKCECodePair,\n  generateState,\n  storePKCEData,\n} from './pkce';\n\n// ============================================================================\n// Types\n// ============================================================================\n\n/**\n * Configuration for redirect mode authentication.\n */\nexport interface RedirectModeConfig {\n  /** AuthHub API base URL */\n  baseUrl: string;\n  /** Application slug or ID */\n  appSlug: string;\n  /** Default callback URL after authentication */\n  callbackUrl: string;\n  /** Token storage implementation */\n  storage: TokenStorage;\n  /** Optional key prefix for storage */\n  keyPrefix?: string;\n  /**\n   * Storage mode to signal to the backend during OAuth callback.\n   * When 'cookie', backend will set httpOnly cookies instead of returning tokens.\n   * @default 'bearer'\n   * @task TASK-500\n   * @feature FTR-109\n   */\n  storageMode?: 'bearer' | 'cookie';\n}\n\n/**\n * Options for redirect operations.\n */\nexport interface RedirectOptions {\n  /** Override the default callback URL */\n  redirectUri?: string;\n  /** Custom state parameter (auto-generated if not provided) */\n  state?: string;\n  /** URL to return to after successful auth (stored for callback) */\n  returnTo?: string;\n  /** Additional query parameters to include */\n  additionalParams?: Record<string, string>;\n}\n\n/**\n * Options specific to registration.\n */\nexport interface RegisterRedirectOptions extends RedirectOptions {\n  /** Pre-fill email in registration form */\n  email?: string;\n  /** Pre-fill name in registration form */\n  name?: string;\n}\n\n/**\n * Options for logout.\n */\nexport interface LogoutOptions {\n  /** Whether to redirect to AuthHub logout endpoint */\n  redirectToAuthHub?: boolean;\n  /** URL to redirect to after logout (if redirectToAuthHub is true) */\n  returnTo?: string;\n  /** Whether to perform a global logout (all sessions) */\n  globalLogout?: boolean;\n}\n\n// ============================================================================\n// Redirect Mode Class\n// ============================================================================\n\n/**\n * Handles redirect-based authentication flows.\n *\n * @example\n * ```typescript\n * const redirectMode = new RedirectMode({\n *   baseUrl: 'https://authhub.example.com',\n *   appSlug: 'my-app',\n *   callbackUrl: 'https://myapp.com/auth/callback',\n *   storage: new LocalStorageTokenStorage(),\n * });\n *\n * // Redirect to login\n * await redirectMode.login();\n *\n * // Redirect to register\n * await redirectMode.register({ email: 'user@example.com' });\n *\n * // Logout\n * await redirectMode.logout();\n * ```\n */\nexport class RedirectMode {\n  private readonly config: RedirectModeConfig;\n\n  constructor(config: RedirectModeConfig) {\n    this.config = config;\n  }\n\n  /**\n   * Build the authorization URL for OAuth flow.\n   *\n   * @param endpoint - Auth portal endpoint ('login' | 'register')\n   * @param options - Redirect options\n   * @returns Authorization URL and generated state\n   */\n  private async buildAuthUrl(\n    endpoint: 'login' | 'register',\n    options: RedirectOptions = {}\n  ): Promise<{ url: string; state: string; codeVerifier: string }> {\n    // Generate PKCE code pair\n    const pkce = await generatePKCECodePair();\n\n    // Generate or use provided state\n    const state = options.state ?? generateState();\n\n    // Build the authorization URL\n    const authUrl = new URL(`/auth/${endpoint}`, this.config.baseUrl);\n\n    // Required parameters\n    authUrl.searchParams.set('app', this.config.appSlug);\n    authUrl.searchParams.set('redirect_uri', options.redirectUri ?? this.config.callbackUrl);\n    authUrl.searchParams.set('response_type', 'code');\n    authUrl.searchParams.set('state', state);\n\n    // PKCE parameters\n    authUrl.searchParams.set('code_challenge', pkce.codeChallenge);\n    authUrl.searchParams.set('code_challenge_method', pkce.codeChallengeMethod);\n\n    // Storage mode - signals backend to use cookies instead of returning tokens\n    // @task TASK-500, @feature FTR-109\n    if (this.config.storageMode === 'cookie') {\n      authUrl.searchParams.set('storage_mode', 'cookie');\n    }\n\n    // Additional parameters\n    if (options.additionalParams) {\n      for (const [key, value] of Object.entries(options.additionalParams)) {\n        authUrl.searchParams.set(key, value);\n      }\n    }\n\n    return {\n      url: authUrl.toString(),\n      state,\n      codeVerifier: pkce.codeVerifier,\n    };\n  }\n\n  /**\n   * Initiate login by redirecting to AuthHub login page.\n   *\n   * This method:\n   * 1. Generates PKCE code verifier and challenge\n   * 2. Generates state parameter for CSRF protection\n   * 3. Stores verifier and state in sessionStorage\n   * 4. Redirects browser to AuthHub login page\n   *\n   * @param options - Login options\n   * @returns Never returns (redirects browser)\n   *\n   * @example\n   * ```typescript\n   * // Basic login\n   * await redirectMode.login();\n   *\n   * // Login with return URL\n   * await redirectMode.login({\n   *   returnTo: '/dashboard',\n   * });\n   *\n   * // Login with custom callback\n   * await redirectMode.login({\n   *   redirectUri: 'https://myapp.com/custom-callback',\n   * });\n   * ```\n   */\n  async login(options: RedirectLoginOptions & RedirectOptions = {}): Promise<void> {\n    const { url, state, codeVerifier } = await this.buildAuthUrl('login', options);\n\n    // Store PKCE data for callback validation\n    storePKCEData(codeVerifier, state, options.returnTo);\n\n    // Redirect to login page\n    this.redirect(url);\n  }\n\n  /**\n   * Initiate registration by redirecting to AuthHub register page.\n   *\n   * @param options - Registration options\n   * @returns Never returns (redirects browser)\n   *\n   * @example\n   * ```typescript\n   * // Basic registration\n   * await redirectMode.register();\n   *\n   * // Pre-fill email\n   * await redirectMode.register({\n   *   email: 'user@example.com',\n   * });\n   *\n   * // Pre-fill email and name\n   * await redirectMode.register({\n   *   email: 'user@example.com',\n   *   name: 'John Doe',\n   * });\n   * ```\n   */\n  async register(options: RegisterRedirectOptions = {}): Promise<void> {\n    const additionalParams: Record<string, string> = { ...options.additionalParams };\n\n    // Pre-fill form fields\n    if (options.email) {\n      additionalParams['email'] = options.email;\n    }\n    if (options.name) {\n      additionalParams['name'] = options.name;\n    }\n\n    const { url, state, codeVerifier } = await this.buildAuthUrl('register', {\n      ...options,\n      additionalParams,\n    });\n\n    // Store PKCE data for callback validation\n    storePKCEData(codeVerifier, state, options.returnTo);\n\n    // Redirect to register page\n    this.redirect(url);\n  }\n\n  /**\n   * Log out the current user.\n   *\n   * This method:\n   * 1. Clears tokens from storage\n   * 2. Optionally redirects to AuthHub logout endpoint\n   *\n   * @param options - Logout options\n   *\n   * @example\n   * ```typescript\n   * // Clear tokens only (no redirect)\n   * await redirectMode.logout();\n   *\n   * // Clear tokens and redirect to AuthHub logout\n   * await redirectMode.logout({\n   *   redirectToAuthHub: true,\n   *   returnTo: 'https://myapp.com/',\n   * });\n   *\n   * // Global logout (all sessions)\n   * await redirectMode.logout({\n   *   redirectToAuthHub: true,\n   *   globalLogout: true,\n   * });\n   * ```\n   */\n  async logout(options: LogoutOptions = {}): Promise<void> {\n    // Clear tokens from storage\n    await this.config.storage.clearTokens();\n\n    // Optionally redirect to AuthHub logout\n    if (options.redirectToAuthHub) {\n      const logoutUrl = new URL('/auth/logout', this.config.baseUrl);\n      logoutUrl.searchParams.set('app', this.config.appSlug);\n\n      if (options.returnTo) {\n        logoutUrl.searchParams.set('redirect_uri', options.returnTo);\n      }\n\n      if (options.globalLogout) {\n        logoutUrl.searchParams.set('global', 'true');\n      }\n\n      this.redirect(logoutUrl.toString());\n    }\n  }\n\n  /**\n   * Get the login URL without redirecting.\n   *\n   * Useful for custom redirect handling or opening in a popup.\n   *\n   * @param options - Login options\n   * @returns Promise with URL, state, and code verifier\n   *\n   * @example\n   * ```typescript\n   * const { url, state, codeVerifier } = await redirectMode.getLoginUrl();\n   *\n   * // Store PKCE data manually\n   * storePKCEData(codeVerifier, state);\n   *\n   * // Open in popup\n   * window.open(url, 'authPopup', 'width=500,height=600');\n   * ```\n   */\n  async getLoginUrl(options: RedirectOptions = {}): Promise<{\n    url: string;\n    state: string;\n    codeVerifier: string;\n  }> {\n    return this.buildAuthUrl('login', options);\n  }\n\n  /**\n   * Get the register URL without redirecting.\n   *\n   * @param options - Registration options\n   * @returns Promise with URL, state, and code verifier\n   */\n  async getRegisterUrl(options: RegisterRedirectOptions = {}): Promise<{\n    url: string;\n    state: string;\n    codeVerifier: string;\n  }> {\n    const additionalParams: Record<string, string> = { ...options.additionalParams };\n\n    if (options.email) {\n      additionalParams['email'] = options.email;\n    }\n    if (options.name) {\n      additionalParams['name'] = options.name;\n    }\n\n    return this.buildAuthUrl('register', {\n      ...options,\n      additionalParams,\n    });\n  }\n\n  /**\n   * Get the logout URL.\n   *\n   * @param options - Logout options\n   * @returns Logout URL\n   */\n  getLogoutUrl(options: LogoutOptions = {}): string {\n    const logoutUrl = new URL('/auth/logout', this.config.baseUrl);\n    logoutUrl.searchParams.set('app', this.config.appSlug);\n\n    if (options.returnTo) {\n      logoutUrl.searchParams.set('redirect_uri', options.returnTo);\n    }\n\n    if (options.globalLogout) {\n      logoutUrl.searchParams.set('global', 'true');\n    }\n\n    return logoutUrl.toString();\n  }\n\n  /**\n   * Redirect the browser to a URL.\n   *\n   * @param url - URL to redirect to\n   */\n  private redirect(url: string): void {\n    if (typeof window !== 'undefined') {\n      window.location.href = url;\n    } else {\n      throw new Error(\n        'Cannot redirect: window is not available. ' +\n        'Use getLoginUrl() or getRegisterUrl() for server-side rendering.'\n      );\n    }\n  }\n}\n\n// ============================================================================\n// Helper Functions\n// ============================================================================\n\n/**\n * Check if the current environment supports redirect mode.\n *\n * @returns True if running in a browser environment\n */\nexport function isRedirectModeSupported(): boolean {\n  return typeof window !== 'undefined' && typeof document !== 'undefined';\n}\n\n/**\n * Check if the current page is an OAuth callback.\n *\n * @param callbackPath - Expected callback path (default: '/auth/callback')\n * @returns True if current URL matches callback path and has code parameter\n */\nexport function isOAuthCallback(callbackPath: string = '/auth/callback'): boolean {\n  if (typeof window === 'undefined') {\n    return false;\n  }\n\n  const { pathname, search } = window.location;\n  const params = new URLSearchParams(search);\n\n  return pathname === callbackPath && params.has('code');\n}\n","/**\n * AuthHub SDK OAuth Callback Handler\n *\n * Handles the OAuth callback after redirect-based authentication.\n * Exchanges authorization code for tokens.\n *\n * @module @authhub/sdk/auth/callback\n * @feature FTR-051\n */\n\nimport type {\n  LoginResult,\n  AuthUser,\n  TokenStorage,\n  TokenResponse,\n  OAuthCallbackParams,\n} from './types';\nimport { AuthenticationError } from './types';\nimport { retrievePKCEData, clearPKCEData } from './pkce';\nimport { createStoredTokenData } from './storage';\n\n// ============================================================================\n// Types\n// ============================================================================\n\n/**\n * Configuration for callback handling.\n */\nexport interface CallbackConfig {\n  /** AuthHub API base URL */\n  baseUrl: string;\n  /** Application slug or ID */\n  appSlug: string;\n  /** Token storage implementation */\n  storage: TokenStorage;\n  /** Callback URL registered with the app */\n  callbackUrl: string;\n  /**\n   * API key for protected operations.\n   * Optional for redirect-mode authentication (auth endpoints don't require it).\n   * @task TASK-501\n   * @feature FTR-110\n   */\n  apiKey?: string;\n}\n\n/**\n * Result of callback handling.\n */\nexport interface CallbackResult extends LoginResult {\n  /** URL to redirect to after successful auth (from storePKCEData) */\n  redirectTo?: string;\n}\n\n// ============================================================================\n// Callback Handler Class\n// ============================================================================\n\n/**\n * Handles OAuth callbacks from redirect-based authentication.\n *\n * @example\n * ```typescript\n * const handler = new CallbackHandler({\n *   baseUrl: 'https://authhub.example.com',\n *   appSlug: 'my-app',\n *   callbackUrl: 'https://myapp.com/auth/callback',\n *   storage: new LocalStorageTokenStorage(),\n *   apiKey: 'ak_xxxxx',\n * });\n *\n * // On callback page\n * const result = await handler.handleCallback();\n * if (result.success) {\n *   console.log('Logged in as', result.user?.email);\n *   // Redirect to app\n *   window.location.href = result.redirectTo || '/dashboard';\n * }\n * ```\n */\nexport class CallbackHandler {\n  private readonly config: CallbackConfig;\n\n  constructor(config: CallbackConfig) {\n    this.config = config;\n  }\n\n  /**\n   * Handle the OAuth callback.\n   *\n   * This method:\n   * 1. Parses the callback URL for code and state\n   * 2. Validates the state parameter against stored value\n   * 3. Exchanges the authorization code for tokens (with PKCE verifier)\n   * 4. Stores the tokens\n   * 5. Cleans up the URL and stored PKCE data\n   *\n   * @param url - Callback URL (defaults to current window.location)\n   * @returns Promise resolving to callback result\n   *\n   * @example\n   * ```typescript\n   * // Handle callback with current URL\n   * const result = await handler.handleCallback();\n   *\n   * // Handle callback with specific URL\n   * const result = await handler.handleCallback('https://myapp.com/callback?code=xxx&state=yyy');\n   * ```\n   */\n  async handleCallback(url?: string): Promise<CallbackResult> {\n    try {\n      // Parse callback parameters\n      const params = this.parseCallbackUrl(url);\n\n      // Check for error response\n      if (params.error) {\n        return this.createErrorResult(params.error, params.error_description);\n      }\n\n      // Validate required parameters\n      if (!params.code) {\n        return this.createErrorResult('missing_code', 'Authorization code not found in callback URL');\n      }\n\n      // Retrieve stored PKCE data\n      const pkceData = retrievePKCEData();\n\n      // Check for expired PKCE data (replay attack prevention)\n      if (pkceData.isExpired) {\n        return this.createErrorResult('state_expired', 'Authentication session expired. Please try logging in again.');\n      }\n\n      // Validate state parameter\n      if (!pkceData.state) {\n        return this.createErrorResult('missing_state', 'OAuth state not found. Session may have expired.');\n      }\n\n      if (params.state !== pkceData.state) {\n        return this.createErrorResult('invalid_state', 'OAuth state mismatch. Possible CSRF attack.');\n      }\n\n      if (!pkceData.codeVerifier) {\n        return this.createErrorResult('missing_verifier', 'PKCE code verifier not found. Session may have expired.');\n      }\n\n      // Exchange code for tokens\n      const tokenResponse = await this.exchangeCodeForTokens(\n        params.code,\n        pkceData.codeVerifier\n      );\n\n      // Store tokens\n      const tokenData = createStoredTokenData(\n        tokenResponse.access_token,\n        tokenResponse.expires_in,\n        tokenResponse.refresh_token\n      );\n      await this.config.storage.setTokens(tokenData);\n\n      // Get user info from token (or fetch from API)\n      const user = await this.getUserFromToken(tokenResponse.access_token);\n\n      // Clean up\n      clearPKCEData();\n      this.cleanupUrl();\n\n      const result: CallbackResult = {\n        success: true,\n        user,\n        accessToken: tokenResponse.access_token,\n        expiresAt: new Date(tokenData.expiresAt),\n      };\n\n      // Conditionally add optional properties\n      if (tokenResponse.refresh_token) {\n        result.refreshToken = tokenResponse.refresh_token;\n      }\n      if (pkceData.redirectTarget) {\n        result.redirectTo = pkceData.redirectTarget;\n      }\n\n      return result;\n    } catch (error) {\n      // Clean up on error\n      clearPKCEData();\n\n      if (error instanceof AuthenticationError) {\n        return {\n          success: false,\n          error,\n        };\n      }\n\n      const message = error instanceof Error ? error.message : 'Unknown error during callback';\n      return {\n        success: false,\n        error: new AuthenticationError(message, 'UNKNOWN_ERROR'),\n      };\n    }\n  }\n\n  /**\n   * Parse the callback URL for OAuth parameters.\n   *\n   * @param url - URL to parse (defaults to window.location.href)\n   * @returns Parsed OAuth callback parameters\n   */\n  private parseCallbackUrl(url?: string): OAuthCallbackParams {\n    const targetUrl = url ?? (typeof window !== 'undefined' ? window.location.href : '');\n    const urlObj = new URL(targetUrl);\n    const searchParams = urlObj.searchParams;\n\n    const result: OAuthCallbackParams = {};\n\n    const code = searchParams.get('code');\n    if (code) result.code = code;\n\n    const state = searchParams.get('state');\n    if (state) result.state = state;\n\n    const error = searchParams.get('error');\n    if (error) result.error = error;\n\n    const errorDesc = searchParams.get('error_description');\n    if (errorDesc) result.error_description = errorDesc;\n\n    return result;\n  }\n\n  /**\n   * Exchange authorization code for tokens.\n   *\n   * @param code - Authorization code\n   * @param codeVerifier - PKCE code verifier\n   * @returns Token response\n   */\n  private async exchangeCodeForTokens(\n    code: string,\n    codeVerifier: string\n  ): Promise<TokenResponse> {\n    // Build headers - X-API-Key is optional for auth endpoints (TASK-501)\n    const headers: Record<string, string> = {\n      'Content-Type': 'application/json',\n    };\n    if (this.config.apiKey) {\n      headers['X-API-Key'] = this.config.apiKey;\n    }\n\n    const response = await fetch(`${this.config.baseUrl}/api/v1/auth/token`, {\n      method: 'POST',\n      headers,\n      body: JSON.stringify({\n        grant_type: 'authorization_code',\n        code,\n        redirect_uri: this.config.callbackUrl,\n        code_verifier: codeVerifier,\n        app: this.config.appSlug,\n      }),\n    });\n\n    if (!response.ok) {\n      const errorBody = await response.json().catch(() => ({}));\n      const errorMessage = (errorBody as Record<string, unknown>)?.['error'] as string ?? 'Token exchange failed';\n      const errorCode = (errorBody as Record<string, unknown>)?.['error_code'] as string ?? 'TOKEN_INVALID';\n\n      throw new AuthenticationError(\n        errorMessage,\n        this.mapErrorCode(errorCode),\n        response.status\n      );\n    }\n\n    return response.json() as Promise<TokenResponse>;\n  }\n\n  /**\n   * Get user information from the access token.\n   *\n   * @param accessToken - Access token\n   * @returns User information\n   */\n  private async getUserFromToken(accessToken: string): Promise<AuthUser> {\n    // Build headers - X-API-Key is optional for auth endpoints (TASK-501)\n    const headers: Record<string, string> = {\n      'Authorization': `Bearer ${accessToken}`,\n    };\n    if (this.config.apiKey) {\n      headers['X-API-Key'] = this.config.apiKey;\n    }\n\n    const response = await fetch(`${this.config.baseUrl}/api/v1/auth/me`, {\n      method: 'GET',\n      headers,\n    });\n\n    if (!response.ok) {\n      // Return minimal user if /me endpoint fails\n      // (tokens are valid even if user info fetch fails)\n      return {\n        id: 'unknown',\n        email: 'unknown',\n        emailVerified: false,\n        createdAt: new Date(),\n      };\n    }\n\n    const userData = await response.json() as Record<string, unknown>;\n\n    const user: AuthUser = {\n      id: String(userData['id'] ?? 'unknown'),\n      email: String(userData['email'] ?? 'unknown'),\n      emailVerified: Boolean(userData['emailVerified']),\n      createdAt: new Date(String(userData['createdAt'] ?? Date.now())),\n    };\n\n    // Conditionally add optional properties\n    if (userData['name']) {\n      user.name = String(userData['name']);\n    }\n    if (userData['avatarUrl']) {\n      user.avatarUrl = String(userData['avatarUrl']);\n    }\n    if (userData['updatedAt']) {\n      user.updatedAt = new Date(String(userData['updatedAt']));\n    }\n    if (userData['metadata']) {\n      user.metadata = userData['metadata'] as Record<string, unknown>;\n    }\n\n    return user;\n  }\n\n  /**\n   * Map error code string to AuthErrorCode.\n   */\n  private mapErrorCode(code: string): import('./types').AuthErrorCode {\n    const codeMap: Record<string, import('./types').AuthErrorCode> = {\n      'invalid_credentials': 'INVALID_CREDENTIALS',\n      'email_not_verified': 'EMAIL_NOT_VERIFIED',\n      'account_locked': 'ACCOUNT_LOCKED',\n      'account_disabled': 'ACCOUNT_DISABLED',\n      'session_expired': 'SESSION_EXPIRED',\n      'token_expired': 'TOKEN_EXPIRED',\n      'token_invalid': 'TOKEN_INVALID',\n      'token_reuse_detected': 'TOKEN_REUSE_DETECTED',\n      'max_sessions_exceeded': 'MAX_SESSIONS_EXCEEDED',\n    };\n\n    return codeMap[code.toLowerCase()] ?? 'UNKNOWN_ERROR';\n  }\n\n  /**\n   * Create an error result.\n   */\n  private createErrorResult(error: string, description?: string): CallbackResult {\n    const message = description ?? error;\n    return {\n      success: false,\n      error: new AuthenticationError(message, this.mapErrorCode(error)),\n    };\n  }\n\n  /**\n   * Clean up the URL by removing OAuth parameters.\n   */\n  private cleanupUrl(): void {\n    if (typeof window === 'undefined' || typeof history === 'undefined') {\n      return;\n    }\n\n    const url = new URL(window.location.href);\n    url.searchParams.delete('code');\n    url.searchParams.delete('state');\n    url.searchParams.delete('error');\n    url.searchParams.delete('error_description');\n\n    // Use replaceState to update URL without adding history entry\n    history.replaceState({}, '', url.toString());\n  }\n}\n\n// ============================================================================\n// Helper Functions\n// ============================================================================\n\n/**\n * Parse OAuth callback parameters from a URL.\n *\n * @param url - URL to parse (defaults to current window.location)\n * @returns Parsed callback parameters\n */\nexport function parseOAuthCallback(url?: string): OAuthCallbackParams {\n  const targetUrl = url ?? (typeof window !== 'undefined' ? window.location.href : '');\n  const urlObj = new URL(targetUrl);\n  const searchParams = urlObj.searchParams;\n\n  const result: OAuthCallbackParams = {};\n\n  const code = searchParams.get('code');\n  if (code) result.code = code;\n\n  const state = searchParams.get('state');\n  if (state) result.state = state;\n\n  const error = searchParams.get('error');\n  if (error) result.error = error;\n\n  const errorDesc = searchParams.get('error_description');\n  if (errorDesc) result.error_description = errorDesc;\n\n  return result;\n}\n\n/**\n * Check if the current URL is an OAuth callback.\n *\n * @param url - URL to check (defaults to current window.location)\n * @returns True if URL contains OAuth callback parameters\n */\nexport function isCallbackUrl(url?: string): boolean {\n  const params = parseOAuthCallback(url);\n  return Boolean(params.code) || Boolean(params.error);\n}\n\n/**\n * Check if the callback contains an error.\n *\n * @param url - URL to check (defaults to current window.location)\n * @returns True if callback contains an error\n */\nexport function hasCallbackError(url?: string): boolean {\n  const params = parseOAuthCallback(url);\n  return Boolean(params.error);\n}\n","/**\n * AuthHub SDK Embedded Mode API\n *\n * Direct API calls for apps with custom authentication UI.\n * Use this when you want full control over the auth experience.\n *\n * @module @authhub/sdk/auth/embedded\n * @feature FTR-051\n */\n\nimport type {\n  LoginResult,\n  RegisterResult,\n  PasswordResetResult,\n  AuthUser,\n  TokenStorage,\n  LoginCredentials,\n  RegisterData,\n} from './types';\nimport { AuthenticationError } from './types';\nimport { createStoredTokenData } from './storage';\n\n// ============================================================================\n// Types\n// ============================================================================\n\n/**\n * Configuration for embedded mode API.\n */\nexport interface EmbeddedModeConfig {\n  /** AuthHub API base URL */\n  baseUrl: string;\n  /** Application slug or ID */\n  appSlug: string;\n  /** Token storage implementation */\n  storage: TokenStorage;\n  /**\n   * API key for protected operations.\n   * Optional for embedded-mode authentication (auth endpoints don't require it).\n   * @task TASK-501\n   * @feature FTR-110\n   */\n  apiKey?: string;\n}\n\n/**\n * Response from user info endpoint.\n */\ninterface UserInfoResponse {\n  id: string;\n  email: string;\n  name?: string;\n  avatarUrl?: string;\n  emailVerified: boolean;\n  createdAt: string;\n  updatedAt?: string;\n  metadata?: Record<string, unknown>;\n}\n\n/**\n * Response from login/register endpoints.\n */\ninterface AuthResponse {\n  access_token: string;\n  refresh_token?: string;\n  expires_in: number;\n  token_type: string;\n  user: UserInfoResponse;\n}\n\n/**\n * API error response structure.\n */\ninterface ApiError {\n  error: string;\n  error_code?: string;\n  message?: string;\n  details?: Record<string, unknown>;\n}\n\n// ============================================================================\n// Embedded Mode Class\n// ============================================================================\n\n/**\n * Provides direct API access for embedded authentication.\n *\n * Use this for apps that want to build their own login/register UI\n * instead of redirecting to AuthHub's auth portal.\n *\n * @example\n * ```typescript\n * const api = new EmbeddedMode({\n *   baseUrl: 'https://authhub.example.com',\n *   appSlug: 'my-app',\n *   storage: new LocalStorageTokenStorage(),\n *   apiKey: 'ak_xxxxx',\n * });\n *\n * // Login with email/password\n * const result = await api.login({ email, password });\n * if (result.success) {\n *   console.log('Logged in as', result.user?.name);\n * } else {\n *   console.error(result.error?.userMessage);\n * }\n *\n * // Register new user\n * const registerResult = await api.register({\n *   email: 'user@example.com',\n *   password: 'securePassword123!',\n *   name: 'John Doe',\n * });\n * ```\n */\nexport class EmbeddedMode {\n  private readonly config: EmbeddedModeConfig;\n\n  constructor(config: EmbeddedModeConfig) {\n    this.config = config;\n  }\n\n  /**\n   * Log in with email and password.\n   *\n   * @param credentials - Login credentials\n   * @returns Login result with user and tokens\n   *\n   * @example\n   * ```typescript\n   * const result = await api.login({\n   *   email: 'user@example.com',\n   *   password: 'myPassword123!',\n   * });\n   *\n   * if (!result.success) {\n   *   switch (result.error?.code) {\n   *     case 'INVALID_CREDENTIALS':\n   *       alert('Invalid email or password');\n   *       break;\n   *     case 'EMAIL_NOT_VERIFIED':\n   *       // Redirect to verification page\n   *       break;\n   *     case 'ACCOUNT_LOCKED':\n   *       alert('Account locked. Try again later.');\n   *       break;\n   *   }\n   * }\n   * ```\n   */\n  async login(credentials: LoginCredentials): Promise<LoginResult> {\n    try {\n      const response = await this.request<AuthResponse>('POST', '/api/v1/auth/login', {\n        email: credentials.email,\n        password: credentials.password,\n        app: this.config.appSlug,\n      });\n\n      // Store tokens\n      const tokenData = createStoredTokenData(\n        response.access_token,\n        response.expires_in,\n        response.refresh_token\n      );\n      await this.config.storage.setTokens(tokenData);\n\n      // Build result\n      const result: LoginResult = {\n        success: true,\n        user: this.mapUser(response.user),\n        accessToken: response.access_token,\n        expiresAt: new Date(tokenData.expiresAt),\n      };\n\n      if (response.refresh_token) {\n        result.refreshToken = response.refresh_token;\n      }\n\n      return result;\n    } catch (error) {\n      if (error instanceof AuthenticationError) {\n        return { success: false, error };\n      }\n      const message = error instanceof Error ? error.message : 'Login failed';\n      return {\n        success: false,\n        error: new AuthenticationError(message, 'UNKNOWN_ERROR'),\n      };\n    }\n  }\n\n  /**\n   * Register a new user.\n   *\n   * @param data - Registration data\n   * @returns Registration result\n   *\n   * @example\n   * ```typescript\n   * const result = await api.register({\n   *   email: 'newuser@example.com',\n   *   password: 'SecurePass123!',\n   *   name: 'Jane Doe',\n   * });\n   *\n   * if (result.success) {\n   *   if (result.requiresEmailVerification) {\n   *     // Show \"check your email\" message\n   *   } else {\n   *     // User is already logged in\n   *   }\n   * }\n   * ```\n   */\n  async register(data: RegisterData): Promise<RegisterResult> {\n    try {\n      const response = await this.request<AuthResponse & { requiresEmailVerification?: boolean }>(\n        'POST',\n        '/api/v1/auth/register',\n        {\n          email: data.email,\n          password: data.password,\n          name: data.name,\n          app: this.config.appSlug,\n        }\n      );\n\n      // If email verification not required, store tokens\n      if (!response.requiresEmailVerification && response.access_token) {\n        const tokenData = createStoredTokenData(\n          response.access_token,\n          response.expires_in,\n          response.refresh_token\n        );\n        await this.config.storage.setTokens(tokenData);\n      }\n\n      const result: RegisterResult = {\n        success: true,\n        user: this.mapUser(response.user),\n      };\n\n      if (response.requiresEmailVerification) {\n        result.requiresEmailVerification = true;\n      }\n\n      return result;\n    } catch (error) {\n      if (error instanceof AuthenticationError) {\n        return { success: false, error };\n      }\n      const message = error instanceof Error ? error.message : 'Registration failed';\n      return {\n        success: false,\n        error: new AuthenticationError(message, 'UNKNOWN_ERROR'),\n      };\n    }\n  }\n\n  /**\n   * Resend verification email.\n   *\n   * @param email - Email address to send verification to\n   * @returns Result indicating success\n   *\n   * @example\n   * ```typescript\n   * const result = await api.resendVerification('user@example.com');\n   * if (result.success) {\n   *   alert('Verification email sent!');\n   * }\n   * ```\n   */\n  async resendVerification(email: string): Promise<PasswordResetResult> {\n    try {\n      await this.request<{ message: string }>('POST', '/api/v1/auth/resend-verification', {\n        email,\n        app: this.config.appSlug,\n      });\n\n      return {\n        success: true,\n        message: 'Verification email sent. Please check your inbox.',\n      };\n    } catch (error) {\n      if (error instanceof AuthenticationError) {\n        return { success: false, error };\n      }\n      const message = error instanceof Error ? error.message : 'Failed to send verification email';\n      return {\n        success: false,\n        error: new AuthenticationError(message, 'UNKNOWN_ERROR'),\n      };\n    }\n  }\n\n  /**\n   * Request a password reset email.\n   *\n   * @param email - Email address for password reset\n   * @returns Result indicating success\n   *\n   * @example\n   * ```typescript\n   * const result = await api.forgotPassword('user@example.com');\n   * if (result.success) {\n   *   alert('Password reset email sent!');\n   * }\n   * ```\n   */\n  async forgotPassword(email: string): Promise<PasswordResetResult> {\n    try {\n      await this.request<{ message: string }>('POST', '/api/v1/auth/forgot-password', {\n        email,\n        app: this.config.appSlug,\n      });\n\n      return {\n        success: true,\n        message: 'Password reset email sent. Please check your inbox.',\n      };\n    } catch (error) {\n      if (error instanceof AuthenticationError) {\n        return { success: false, error };\n      }\n      const message = error instanceof Error ? error.message : 'Failed to send reset email';\n      return {\n        success: false,\n        error: new AuthenticationError(message, 'UNKNOWN_ERROR'),\n      };\n    }\n  }\n\n  /**\n   * Reset password with token from email.\n   *\n   * @param token - Reset token from email link\n   * @param newPassword - New password to set\n   * @returns Result indicating success\n   *\n   * @example\n   * ```typescript\n   * const result = await api.resetPassword(token, 'NewSecurePass123!');\n   * if (result.success) {\n   *   alert('Password reset successfully! Please log in.');\n   * }\n   * ```\n   */\n  async resetPassword(token: string, newPassword: string): Promise<PasswordResetResult> {\n    try {\n      await this.request<{ message: string }>('POST', '/api/v1/auth/reset-password', {\n        token,\n        password: newPassword,\n        app: this.config.appSlug,\n      });\n\n      return {\n        success: true,\n        message: 'Password reset successfully. You can now log in with your new password.',\n      };\n    } catch (error) {\n      if (error instanceof AuthenticationError) {\n        return { success: false, error };\n      }\n      const message = error instanceof Error ? error.message : 'Failed to reset password';\n      return {\n        success: false,\n        error: new AuthenticationError(message, 'UNKNOWN_ERROR'),\n      };\n    }\n  }\n\n  /**\n   * Get current user information.\n   *\n   * @returns Current user or null if not authenticated\n   *\n   * @example\n   * ```typescript\n   * const user = await api.me();\n   * if (user) {\n   *   console.log('Logged in as:', user.email);\n   * } else {\n   *   console.log('Not authenticated');\n   * }\n   * ```\n   */\n  async me(): Promise<AuthUser | null> {\n    const tokens = await this.config.storage.getTokens();\n    if (!tokens) {\n      return null;\n    }\n\n    try {\n      // Build headers - X-API-Key is optional for auth endpoints (TASK-501)\n      const headers: Record<string, string> = {\n        'Authorization': `Bearer ${tokens.accessToken}`,\n      };\n      if (this.config.apiKey) {\n        headers['X-API-Key'] = this.config.apiKey;\n      }\n\n      const response = await fetch(`${this.config.baseUrl}/api/v1/auth/me`, {\n        method: 'GET',\n        headers,\n      });\n\n      if (!response.ok) {\n        if (response.status === 401) {\n          // Token is invalid, clear storage\n          await this.config.storage.clearTokens();\n          return null;\n        }\n        return null;\n      }\n\n      const userData = await response.json() as UserInfoResponse;\n      return this.mapUser(userData);\n    } catch {\n      return null;\n    }\n  }\n\n  /**\n   * Log out the current user.\n   * Clears tokens and optionally revokes session on server.\n   *\n   * @param revokeSession - Whether to revoke server session (default: true)\n   */\n  async logout(revokeSession: boolean = true): Promise<void> {\n    if (revokeSession) {\n      const tokens = await this.config.storage.getTokens();\n      if (tokens) {\n        try {\n          // Build headers - X-API-Key is optional for auth endpoints (TASK-501)\n          const headers: Record<string, string> = {\n            'Authorization': `Bearer ${tokens.accessToken}`,\n          };\n          if (this.config.apiKey) {\n            headers['X-API-Key'] = this.config.apiKey;\n          }\n\n          await fetch(`${this.config.baseUrl}/api/v1/auth/logout`, {\n            method: 'POST',\n            headers,\n          });\n        } catch {\n          // Ignore errors during logout\n        }\n      }\n    }\n\n    await this.config.storage.clearTokens();\n  }\n\n  /**\n   * Make an authenticated API request.\n   * X-API-Key is optional for auth endpoints (TASK-501).\n   */\n  private async request<T>(\n    method: 'GET' | 'POST' | 'PUT' | 'DELETE',\n    path: string,\n    body?: Record<string, unknown>\n  ): Promise<T> {\n    // Build headers - X-API-Key is optional for auth endpoints\n    const headers: Record<string, string> = {\n      'Content-Type': 'application/json',\n    };\n    if (this.config.apiKey) {\n      headers['X-API-Key'] = this.config.apiKey;\n    }\n\n    const options: RequestInit = {\n      method,\n      headers,\n    };\n\n    if (body) {\n      options.body = JSON.stringify(body);\n    }\n\n    const response = await fetch(`${this.config.baseUrl}${path}`, options);\n\n    if (!response.ok) {\n      const errorBody = await response.json().catch(() => ({})) as ApiError;\n      throw this.mapApiError(errorBody, response.status);\n    }\n\n    return response.json() as Promise<T>;\n  }\n\n  /**\n   * Map API error response to AuthenticationError.\n   */\n  private mapApiError(error: ApiError, statusCode: number): AuthenticationError {\n    const message = error.message ?? error.error ?? 'Request failed';\n    const code = this.mapErrorCode(error.error_code ?? error.error ?? '');\n\n    return new AuthenticationError(message, code, statusCode, error.details);\n  }\n\n  /**\n   * Map error code string to AuthErrorCode.\n   */\n  private mapErrorCode(code: string): import('./types').AuthErrorCode {\n    const codeMap: Record<string, import('./types').AuthErrorCode> = {\n      'invalid_credentials': 'INVALID_CREDENTIALS',\n      'email_not_verified': 'EMAIL_NOT_VERIFIED',\n      'account_locked': 'ACCOUNT_LOCKED',\n      'account_disabled': 'ACCOUNT_DISABLED',\n      'session_expired': 'SESSION_EXPIRED',\n      'token_expired': 'TOKEN_EXPIRED',\n      'token_invalid': 'TOKEN_INVALID',\n      'token_reuse_detected': 'TOKEN_REUSE_DETECTED',\n      'max_sessions_exceeded': 'MAX_SESSIONS_EXCEEDED',\n      'password_too_weak': 'PASSWORD_TOO_WEAK',\n      'email_already_exists': 'EMAIL_ALREADY_EXISTS',\n      'invalid_reset_token': 'INVALID_RESET_TOKEN',\n      'reset_token_expired': 'RESET_TOKEN_EXPIRED',\n    };\n\n    return codeMap[code.toLowerCase()] ?? 'UNKNOWN_ERROR';\n  }\n\n  /**\n   * Map user response to AuthUser.\n   */\n  private mapUser(userData: UserInfoResponse): AuthUser {\n    const user: AuthUser = {\n      id: userData.id,\n      email: userData.email,\n      emailVerified: userData.emailVerified,\n      createdAt: new Date(userData.createdAt),\n    };\n\n    if (userData.name) {\n      user.name = userData.name;\n    }\n    if (userData.avatarUrl) {\n      user.avatarUrl = userData.avatarUrl;\n    }\n    if (userData.updatedAt) {\n      user.updatedAt = new Date(userData.updatedAt);\n    }\n    if (userData.metadata) {\n      user.metadata = userData.metadata;\n    }\n\n    return user;\n  }\n}\n","/**\n * AuthHub SDK Token Manager\n *\n * Manages token lifecycle including automatic refresh before expiration.\n * Integrates with FTR-065's token rotation feature.\n *\n * @module @authhub/sdk/auth/token-manager\n * @feature FTR-051\n */\n\nimport type { RefreshResult, TokenStorage, StoredTokenData } from './types';\nimport { AuthenticationError } from './types';\nimport { isTokenExpired, createStoredTokenData } from './storage';\n\n// ============================================================================\n// Constants\n// ============================================================================\n\n/** Default refresh threshold in seconds */\nconst DEFAULT_REFRESH_THRESHOLD = 60;\n\n/** Minimum refresh threshold to prevent rapid refreshes */\nconst MIN_REFRESH_THRESHOLD = 10;\n\n/** Maximum retry attempts for token refresh */\nconst MAX_REFRESH_RETRIES = 2;\n\n/** Backoff delay between retry attempts in ms */\nconst RETRY_BACKOFF_MS = 1000;\n\n// ============================================================================\n// Types\n// ============================================================================\n\n/**\n * Configuration for the token manager.\n */\nexport interface TokenManagerConfig {\n  /** AuthHub API base URL */\n  baseUrl: string;\n  /**\n   * API key for protected operations.\n   * Optional for redirect-mode authentication (refresh endpoint uses JWT only).\n   * @task TASK-501\n   * @feature FTR-110\n   */\n  apiKey?: string;\n  /** Token storage implementation */\n  storage: TokenStorage;\n  /** Seconds before expiry to trigger refresh (default: 60) */\n  refreshThreshold?: number;\n  /** Callback when tokens are refreshed */\n  onTokenRefresh?: (tokens: StoredTokenData) => void;\n  /** Callback when session expires */\n  onSessionExpired?: (error: AuthenticationError) => void;\n  /** Callback when token reuse is detected (security breach) */\n  onTokenReuseDetected?: () => void;\n}\n\n/**\n * Token refresh response from the API.\n */\ninterface TokenRefreshResponse {\n  access_token: string;\n  refresh_token?: string;\n  expires_in: number;\n  token_type: string;\n}\n\n/**\n * API error response.\n */\ninterface ApiError {\n  error: string;\n  error_code?: string;\n  message?: string;\n}\n\n// ============================================================================\n// Token Manager Class\n// ============================================================================\n\n/**\n * Manages token lifecycle with automatic refresh.\n *\n * @example\n * ```typescript\n * const manager = new TokenManager({\n *   baseUrl: 'https://authhub.example.com',\n *   apiKey: 'ak_xxxxx',\n *   storage: new LocalStorageTokenStorage(),\n *   refreshThreshold: 60, // Refresh 60 seconds before expiry\n *   onSessionExpired: () => {\n *     // Redirect to login\n *     window.location.href = '/login';\n *   },\n * });\n *\n * // Start auto-refresh when user logs in\n * manager.startAutoRefresh();\n *\n * // Get a valid token for API calls\n * const token = await manager.getValidToken();\n *\n * // Stop refresh on logout\n * manager.stopAutoRefresh();\n * ```\n */\nexport class TokenManager {\n  private readonly config: TokenManagerConfig;\n  private readonly refreshThreshold: number;\n  private refreshTimer: ReturnType<typeof setTimeout> | null = null;\n  private isRefreshing: boolean = false;\n  private refreshPromise: Promise<RefreshResult> | null = null;\n\n  constructor(config: TokenManagerConfig) {\n    this.config = config;\n    this.refreshThreshold = Math.max(\n      config.refreshThreshold ?? DEFAULT_REFRESH_THRESHOLD,\n      MIN_REFRESH_THRESHOLD\n    );\n  }\n\n  /**\n   * Get a valid access token, refreshing if necessary.\n   *\n   * @returns Valid access token or null if not authenticated\n   *\n   * @example\n   * ```typescript\n   * const token = await manager.getValidToken();\n   * if (token) {\n   *   await fetch('/api/data', {\n   *     headers: { 'Authorization': `Bearer ${token}` }\n   *   });\n   * }\n   * ```\n   */\n  async getValidToken(): Promise<string | null> {\n    const tokens = await this.config.storage.getTokens();\n\n    if (!tokens) {\n      return null;\n    }\n\n    // Check if token needs refresh\n    if (isTokenExpired(tokens, this.refreshThreshold)) {\n      const result = await this.refreshToken();\n      if (result.success && result.accessToken) {\n        return result.accessToken;\n      }\n      return null;\n    }\n\n    return tokens.accessToken;\n  }\n\n  /**\n   * Refresh the current access token.\n   *\n   * Handles FTR-065's token rotation - stores the new refresh token\n   * and detects token reuse attacks.\n   *\n   * @returns Refresh result\n   */\n  async refreshToken(): Promise<RefreshResult> {\n    // Prevent concurrent refresh attempts\n    if (this.isRefreshing && this.refreshPromise) {\n      return this.refreshPromise;\n    }\n\n    this.isRefreshing = true;\n    this.refreshPromise = this.doRefresh();\n\n    try {\n      return await this.refreshPromise;\n    } finally {\n      this.isRefreshing = false;\n      this.refreshPromise = null;\n    }\n  }\n\n  /**\n   * Internal refresh implementation with retry logic.\n   */\n  private async doRefresh(): Promise<RefreshResult> {\n    const tokens = await this.config.storage.getTokens();\n\n    if (!tokens?.refreshToken) {\n      const error = new AuthenticationError(\n        'No refresh token available',\n        'SESSION_EXPIRED'\n      );\n      this.handleSessionExpired(error);\n      return { success: false, error };\n    }\n\n    let lastError: AuthenticationError | null = null;\n\n    for (let attempt = 0; attempt <= MAX_REFRESH_RETRIES; attempt++) {\n      try {\n        const response = await this.callRefreshEndpoint(tokens.refreshToken);\n\n        // Store new tokens (FTR-065: new refresh token on each refresh)\n        const tokenData = createStoredTokenData(\n          response.access_token,\n          response.expires_in,\n          response.refresh_token\n        );\n        await this.config.storage.setTokens(tokenData);\n\n        // Notify callback\n        this.config.onTokenRefresh?.(tokenData);\n\n        // Reschedule auto-refresh\n        this.scheduleRefresh(tokenData);\n\n        const result: RefreshResult = {\n          success: true,\n          accessToken: response.access_token,\n          expiresAt: new Date(tokenData.expiresAt),\n        };\n\n        if (response.refresh_token) {\n          result.refreshToken = response.refresh_token;\n        }\n\n        return result;\n      } catch (error) {\n        if (error instanceof AuthenticationError) {\n          // FTR-065: Handle token reuse detection\n          if (error.code === 'TOKEN_REUSE_DETECTED') {\n            this.config.onTokenReuseDetected?.();\n            await this.config.storage.clearTokens();\n            this.stopAutoRefresh();\n\n            const securityError = new AuthenticationError(\n              'Security breach detected. Please log in again.',\n              'TOKEN_REUSE_DETECTED',\n              error.statusCode\n            );\n            this.handleSessionExpired(securityError);\n            return { success: false, error: securityError };\n          }\n\n          // Non-retryable errors\n          if (!error.isRetryable) {\n            this.handleSessionExpired(error);\n            return { success: false, error };\n          }\n\n          lastError = error;\n        } else {\n          lastError = new AuthenticationError(\n            error instanceof Error ? error.message : 'Token refresh failed',\n            'NETWORK_ERROR'\n          );\n        }\n\n        // Wait before retry\n        if (attempt < MAX_REFRESH_RETRIES) {\n          await this.delay(RETRY_BACKOFF_MS * (attempt + 1));\n        }\n      }\n    }\n\n    // All retries exhausted\n    const error = lastError ?? new AuthenticationError(\n      'Token refresh failed after retries',\n      'SERVER_ERROR'\n    );\n    this.handleSessionExpired(error);\n    return { success: false, error };\n  }\n\n  /**\n   * Call the token refresh endpoint.\n   * X-API-Key is optional for auth endpoints (TASK-501).\n   */\n  private async callRefreshEndpoint(refreshToken: string): Promise<TokenRefreshResponse> {\n    // Build headers - X-API-Key is optional for auth endpoints\n    const headers: Record<string, string> = {\n      'Content-Type': 'application/json',\n    };\n    if (this.config.apiKey) {\n      headers['X-API-Key'] = this.config.apiKey;\n    }\n\n    const response = await fetch(`${this.config.baseUrl}/api/v1/auth/refresh`, {\n      method: 'POST',\n      headers,\n      body: JSON.stringify({ refresh_token: refreshToken }),\n    });\n\n    if (!response.ok) {\n      const errorBody = await response.json().catch(() => ({})) as ApiError;\n      const code = this.mapErrorCode(errorBody.error_code ?? errorBody.error ?? '');\n\n      throw new AuthenticationError(\n        errorBody.message ?? errorBody.error ?? 'Token refresh failed',\n        code,\n        response.status\n      );\n    }\n\n    return response.json() as Promise<TokenRefreshResponse>;\n  }\n\n  /**\n   * Start automatic token refresh.\n   *\n   * Call this after successful login or on app initialization.\n   */\n  async startAutoRefresh(): Promise<void> {\n    const tokens = await this.config.storage.getTokens();\n    if (tokens) {\n      this.scheduleRefresh(tokens);\n    }\n  }\n\n  /**\n   * Stop automatic token refresh.\n   *\n   * Call this on logout or when the user leaves.\n   */\n  stopAutoRefresh(): void {\n    if (this.refreshTimer) {\n      clearTimeout(this.refreshTimer);\n      this.refreshTimer = null;\n    }\n  }\n\n  /**\n   * Schedule the next token refresh.\n   */\n  private scheduleRefresh(tokens: StoredTokenData): void {\n    this.stopAutoRefresh();\n\n    const expiresIn = tokens.expiresAt - Date.now();\n    const refreshIn = Math.max(\n      expiresIn - this.refreshThreshold * 1000,\n      1000 // Minimum 1 second\n    );\n\n    this.refreshTimer = setTimeout(async () => {\n      await this.refreshToken();\n    }, refreshIn);\n  }\n\n  /**\n   * Handle session expiration.\n   */\n  private handleSessionExpired(error: AuthenticationError): void {\n    this.stopAutoRefresh();\n    this.config.onSessionExpired?.(error);\n  }\n\n  /**\n   * Map error code string to AuthErrorCode.\n   */\n  private mapErrorCode(code: string): import('./types').AuthErrorCode {\n    const codeMap: Record<string, import('./types').AuthErrorCode> = {\n      'token_expired': 'TOKEN_EXPIRED',\n      'token_invalid': 'TOKEN_INVALID',\n      'token_reuse_detected': 'TOKEN_REUSE_DETECTED',\n      'session_expired': 'SESSION_EXPIRED',\n      'max_sessions_exceeded': 'MAX_SESSIONS_EXCEEDED',\n    };\n\n    return codeMap[code.toLowerCase()] ?? 'UNKNOWN_ERROR';\n  }\n\n  /**\n   * Delay helper.\n   */\n  private delay(ms: number): Promise<void> {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n  }\n}\n\n// ============================================================================\n// JWT Utilities\n// ============================================================================\n\n/**\n * Decode a JWT payload without verification.\n *\n * Note: This does NOT verify the signature. For validation,\n * the server must be trusted.\n *\n * @param token - JWT token string\n * @returns Decoded payload or null if invalid\n */\nexport function decodeJwtPayload(token: string): Record<string, unknown> | null {\n  try {\n    const parts = token.split('.');\n    if (parts.length !== 3) {\n      return null;\n    }\n\n    const payload = parts[1];\n    if (!payload) {\n      return null;\n    }\n\n    // Base64url decode\n    const base64 = payload.replace(/-/g, '+').replace(/_/g, '/');\n    const padded = base64.padEnd(base64.length + (4 - (base64.length % 4)) % 4, '=');\n\n    let jsonString: string;\n    if (typeof atob !== 'undefined') {\n      jsonString = atob(padded);\n    } else if (typeof Buffer !== 'undefined') {\n      jsonString = Buffer.from(padded, 'base64').toString('utf-8');\n    } else {\n      return null;\n    }\n\n    return JSON.parse(jsonString) as Record<string, unknown>;\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Get the expiration timestamp from a JWT.\n *\n * @param token - JWT token string\n * @returns Expiration timestamp in milliseconds, or null if invalid\n */\nexport function getJwtExpiration(token: string): number | null {\n  const payload = decodeJwtPayload(token);\n  if (!payload) {\n    return null;\n  }\n\n  const exp = payload['exp'];\n  if (typeof exp !== 'number') {\n    return null;\n  }\n\n  // JWT exp is in seconds, convert to milliseconds\n  return exp * 1000;\n}\n\n/**\n * Check if a JWT is expired.\n *\n * @param token - JWT token string\n * @param thresholdSeconds - Consider expired if within this many seconds\n * @returns True if expired or invalid\n */\nexport function isJwtExpired(token: string, thresholdSeconds: number = 0): boolean {\n  const exp = getJwtExpiration(token);\n  if (exp === null) {\n    return true; // Treat invalid tokens as expired\n  }\n\n  return Date.now() + thresholdSeconds * 1000 >= exp;\n}\n","/**\n * AuthHub SDK Auth State Management\n *\n * Reactive state tracking with pub/sub for UI updates.\n *\n * @module @authhub/sdk/auth/state\n * @feature FTR-051\n */\n\nimport type { AuthState, AuthUser, TokenStorage, StoredTokenData } from './types';\nimport { AuthenticationError } from './types';\n\n// ============================================================================\n// Types\n// ============================================================================\n\n/**\n * Auth events that can be subscribed to.\n */\nexport type AuthEvent =\n  | 'SIGNED_IN'\n  | 'SIGNED_OUT'\n  | 'TOKEN_REFRESHED'\n  | 'USER_UPDATED'\n  | 'SESSION_EXPIRED'\n  | 'LOADING';\n\n/**\n * Event payload types.\n */\nexport interface AuthEventPayload {\n  SIGNED_IN: { user: AuthUser; accessToken: string };\n  SIGNED_OUT: { reason?: string };\n  TOKEN_REFRESHED: { accessToken: string; expiresAt: Date };\n  USER_UPDATED: { user: AuthUser };\n  SESSION_EXPIRED: { error: AuthenticationError };\n  LOADING: { isLoading: boolean };\n}\n\n/**\n * Callback type for auth state changes.\n */\nexport type AuthStateCallback = (state: AuthState) => void;\n\n/**\n * Callback type for specific auth events.\n */\nexport type AuthEventCallback<E extends AuthEvent> = (\n  payload: AuthEventPayload[E]\n) => void;\n\n/**\n * Unsubscribe function returned from subscribe methods.\n */\nexport type Unsubscribe = () => void;\n\n/**\n * Configuration for auth state manager.\n */\nexport interface AuthStateManagerConfig {\n  /** Token storage to read auth state from */\n  storage: TokenStorage;\n  /** Optional user fetcher function */\n  fetchUser?: (accessToken: string) => Promise<AuthUser>;\n}\n\n// ============================================================================\n// Auth State Manager\n// ============================================================================\n\n/**\n * Manages authentication state with reactive subscriptions.\n *\n * @example\n * ```typescript\n * const stateManager = new AuthStateManager({\n *   storage: new LocalStorageTokenStorage(),\n * });\n *\n * // Subscribe to state changes\n * const unsubscribe = stateManager.onStateChange((state) => {\n *   console.log('Auth state:', state);\n * });\n *\n * // Subscribe to specific events\n * stateManager.on('SIGNED_IN', ({ user }) => {\n *   console.log('Welcome,', user.name);\n * });\n *\n * // Check current state\n * if (stateManager.isAuthenticated()) {\n *   const user = stateManager.getUser();\n * }\n *\n * // Clean up\n * unsubscribe();\n * ```\n */\nexport class AuthStateManager {\n  private readonly config: AuthStateManagerConfig;\n  private currentState: AuthState;\n  private currentUser: AuthUser | null = null;\n  private stateListeners: Set<AuthStateCallback> = new Set();\n  private eventListeners: Map<AuthEvent, Set<AuthEventCallback<AuthEvent>>> = new Map();\n\n  constructor(config: AuthStateManagerConfig) {\n    this.config = config;\n\n    // Initialize with loading state\n    this.currentState = {\n      isAuthenticated: false,\n      isLoading: true,\n      user: null,\n    };\n\n    // Initialize event listener maps\n    const events: AuthEvent[] = [\n      'SIGNED_IN',\n      'SIGNED_OUT',\n      'TOKEN_REFRESHED',\n      'USER_UPDATED',\n      'SESSION_EXPIRED',\n      'LOADING',\n    ];\n    events.forEach((event) => {\n      this.eventListeners.set(event, new Set());\n    });\n  }\n\n  /**\n   * Initialize state from storage.\n   * Call this on app startup.\n   */\n  async initialize(): Promise<void> {\n    this.emitEvent('LOADING', { isLoading: true });\n\n    try {\n      const tokens = await this.config.storage.getTokens();\n\n      if (tokens) {\n        // Try to get user info if we have a fetcher\n        if (this.config.fetchUser) {\n          try {\n            this.currentUser = await this.config.fetchUser(tokens.accessToken);\n          } catch {\n            // Token might be invalid\n            this.currentUser = null;\n          }\n        }\n\n        if (this.currentUser || !this.config.fetchUser) {\n          this.updateState({\n            isAuthenticated: true,\n            isLoading: false,\n            user: this.currentUser,\n            accessToken: tokens.accessToken,\n            expiresAt: new Date(tokens.expiresAt),\n          });\n          return;\n        }\n      }\n\n      // Not authenticated\n      this.updateState({\n        isAuthenticated: false,\n        isLoading: false,\n        user: null,\n      });\n    } finally {\n      this.emitEvent('LOADING', { isLoading: false });\n    }\n  }\n\n  /**\n   * Get the current authentication state.\n   */\n  getState(): AuthState {\n    return { ...this.currentState };\n  }\n\n  /**\n   * Get the current user if authenticated.\n   */\n  getUser(): AuthUser | null {\n    return this.currentUser ? { ...this.currentUser } : null;\n  }\n\n  /**\n   * Check if user is authenticated.\n   */\n  isAuthenticated(): boolean {\n    return this.currentState.isAuthenticated;\n  }\n\n  /**\n   * Check if auth state is still loading.\n   */\n  isLoading(): boolean {\n    return this.currentState.isLoading;\n  }\n\n  /**\n   * Subscribe to all auth state changes.\n   *\n   * @param callback - Function called when state changes\n   * @returns Unsubscribe function\n   */\n  onStateChange(callback: AuthStateCallback): Unsubscribe {\n    this.stateListeners.add(callback);\n\n    // Immediately call with current state\n    callback(this.getState());\n\n    return () => {\n      this.stateListeners.delete(callback);\n    };\n  }\n\n  /**\n   * Subscribe to specific auth events.\n   *\n   * @param event - Event type to listen for\n   * @param callback - Function called when event fires\n   * @returns Unsubscribe function\n   */\n  on<E extends AuthEvent>(\n    event: E,\n    callback: AuthEventCallback<E>\n  ): Unsubscribe {\n    const listeners = this.eventListeners.get(event);\n    if (listeners) {\n      listeners.add(callback as AuthEventCallback<AuthEvent>);\n    }\n\n    return () => {\n      listeners?.delete(callback as AuthEventCallback<AuthEvent>);\n    };\n  }\n\n  /**\n   * Update state after successful login.\n   */\n  setSignedIn(user: AuthUser, tokens: StoredTokenData): void {\n    this.currentUser = user;\n\n    this.updateState({\n      isAuthenticated: true,\n      isLoading: false,\n      user,\n      accessToken: tokens.accessToken,\n      expiresAt: new Date(tokens.expiresAt),\n    });\n\n    this.emitEvent('SIGNED_IN', {\n      user,\n      accessToken: tokens.accessToken,\n    });\n  }\n\n  /**\n   * Update state after logout.\n   */\n  setSignedOut(reason?: string): void {\n    this.currentUser = null;\n\n    this.updateState({\n      isAuthenticated: false,\n      isLoading: false,\n      user: null,\n    });\n\n    const payload: AuthEventPayload['SIGNED_OUT'] = {};\n    if (reason) {\n      payload.reason = reason;\n    }\n\n    this.emitEvent('SIGNED_OUT', payload);\n  }\n\n  /**\n   * Update state after token refresh.\n   */\n  setTokenRefreshed(tokens: StoredTokenData): void {\n    this.updateState({\n      ...this.currentState,\n      accessToken: tokens.accessToken,\n      expiresAt: new Date(tokens.expiresAt),\n    });\n\n    this.emitEvent('TOKEN_REFRESHED', {\n      accessToken: tokens.accessToken,\n      expiresAt: new Date(tokens.expiresAt),\n    });\n  }\n\n  /**\n   * Update user information.\n   */\n  setUser(user: AuthUser): void {\n    this.currentUser = user;\n\n    this.updateState({\n      ...this.currentState,\n      user,\n    });\n\n    this.emitEvent('USER_UPDATED', { user });\n  }\n\n  /**\n   * Handle session expiration.\n   */\n  setSessionExpired(error: AuthenticationError): void {\n    this.currentUser = null;\n\n    this.updateState({\n      isAuthenticated: false,\n      isLoading: false,\n      user: null,\n      error,\n    });\n\n    this.emitEvent('SESSION_EXPIRED', { error });\n  }\n\n  /**\n   * Update internal state and notify listeners.\n   */\n  private updateState(newState: AuthState): void {\n    this.currentState = newState;\n\n    // Notify all state listeners\n    this.stateListeners.forEach((listener) => {\n      try {\n        listener(this.getState());\n      } catch (error) {\n        console.error('AuthStateManager: Error in state listener', error);\n      }\n    });\n  }\n\n  /**\n   * Emit an event to listeners.\n   */\n  private emitEvent<E extends AuthEvent>(\n    event: E,\n    payload: AuthEventPayload[E]\n  ): void {\n    const listeners = this.eventListeners.get(event);\n    if (!listeners) return;\n\n    listeners.forEach((listener) => {\n      try {\n        (listener as AuthEventCallback<E>)(payload);\n      } catch (error) {\n        console.error(`AuthStateManager: Error in ${event} listener`, error);\n      }\n    });\n  }\n\n  /**\n   * Clear all listeners.\n   */\n  clearListeners(): void {\n    this.stateListeners.clear();\n    this.eventListeners.forEach((listeners) => listeners.clear());\n  }\n}\n\n// ============================================================================\n// Convenience Functions\n// ============================================================================\n\n/**\n * Create initial loading state.\n */\nexport function createLoadingState(): AuthState {\n  return {\n    isAuthenticated: false,\n    isLoading: true,\n    user: null,\n  };\n}\n\n/**\n * Create unauthenticated state.\n */\nexport function createUnauthenticatedState(): AuthState {\n  return {\n    isAuthenticated: false,\n    isLoading: false,\n    user: null,\n  };\n}\n\n/**\n * Create authenticated state.\n */\nexport function createAuthenticatedState(\n  user: AuthUser,\n  accessToken: string,\n  expiresAt: Date\n): AuthState {\n  return {\n    isAuthenticated: true,\n    isLoading: false,\n    user,\n    accessToken,\n    expiresAt,\n  };\n}\n","/**\n * AuthHub SDK Auth Client\n *\n * Main auth module facade that integrates all auth components.\n *\n * @module @authhub/sdk/auth/client\n * @feature FTR-051\n */\n\nimport type {\n  AuthModuleConfig,\n  AuthState,\n  AuthUser,\n  LoginResult,\n  RegisterResult,\n  RefreshResult,\n  PasswordResetResult,\n  LoginCredentials,\n  RegisterData,\n  RedirectLoginOptions,\n  TokenStorage,\n} from './types';\nimport { AuthenticationError } from './types';\nimport { createTokenStorage } from './storage';\nimport { RedirectMode } from './redirect';\nimport { CallbackHandler } from './callback';\nimport { EmbeddedMode } from './embedded';\nimport { TokenManager } from './token-manager';\nimport { AuthStateManager } from './state';\n\n// ============================================================================\n// Types\n// ============================================================================\n\n/**\n * Configuration for creating an AuthClient.\n */\nexport interface AuthClientConfig {\n  /** AuthHub API base URL */\n  baseUrl: string;\n  /**\n   * API key for protected operations (AI, Database, Secrets).\n   * Optional for redirect-mode authentication only.\n   * @task TASK-501\n   * @feature FTR-110\n   */\n  apiKey?: string;\n  /** Application slug */\n  appSlug: string;\n  /** Auth module configuration */\n  auth?: AuthModuleConfig;\n}\n\n// ============================================================================\n// Auth Client\n// ============================================================================\n\n/**\n * Main auth client that provides a unified interface for authentication.\n *\n * Supports both redirect mode (AuthHub portal) and embedded mode (custom UI).\n *\n * @example\n * ```typescript\n * // Create client in redirect mode\n * const auth = new AuthClient({\n *   baseUrl: 'https://authhub.example.com',\n *   apiKey: 'ak_xxxxx',\n *   appSlug: 'my-app',\n *   auth: {\n *     mode: 'redirect',\n *     callbackUrl: 'https://myapp.com/auth/callback',\n *   },\n * });\n *\n * // Login (redirects to AuthHub)\n * await auth.login();\n *\n * // Handle callback on /auth/callback page\n * if (auth.isCallback()) {\n *   await auth.handleCallback();\n * }\n *\n * // Check auth state\n * const { isAuthenticated, user } = auth.getState();\n * ```\n */\nexport class AuthClient {\n  private readonly config: AuthClientConfig;\n  private readonly storage: TokenStorage;\n  public readonly stateManager: AuthStateManager;\n  public readonly tokenManager: TokenManager;\n  public readonly redirectMode: RedirectMode | null = null;\n  public readonly embeddedMode: EmbeddedMode | null = null;\n  public readonly callbackHandler: CallbackHandler | null = null;\n  public readonly mode: 'redirect' | 'embedded';\n\n  constructor(config: AuthClientConfig) {\n    this.config = config;\n    this.mode = config.auth?.mode ?? 'redirect';\n\n    // Initialize storage\n    const storageType = config.auth?.storage ?? 'localStorage';\n    if (storageType === 'custom' && config.auth?.customStorage) {\n      this.storage = config.auth.customStorage;\n    } else if (storageType === 'custom') {\n      throw new Error('Custom storage selected but customStorage not provided');\n    } else if (storageType === 'cookie') {\n      // Cookie mode - use CookieTokenStorage\n      this.storage = createTokenStorage('cookie');\n    } else {\n      this.storage = createTokenStorage(storageType, config.auth?.storageKeyPrefix);\n    }\n\n    // Initialize state manager\n    const stateManagerConfig: import('./state').AuthStateManagerConfig = {\n      storage: this.storage,\n    };\n    if (config.auth?.mode === 'embedded') {\n      stateManagerConfig.fetchUser = async (token) => {\n        // Build headers - X-API-Key is optional for auth endpoints (TASK-501)\n        const headers: Record<string, string> = {\n          'Authorization': `Bearer ${token}`,\n        };\n        if (config.apiKey) {\n          headers['X-API-Key'] = config.apiKey;\n        }\n        const response = await fetch(`${config.baseUrl}/api/v1/auth/me`, {\n          headers,\n        });\n        if (!response.ok) throw new Error('Failed to fetch user');\n        return response.json();\n      };\n    }\n    this.stateManager = new AuthStateManager(stateManagerConfig);\n\n    // Initialize token manager - apiKey is optional for auth endpoints (TASK-501)\n    const tokenManagerConfig: import('./token-manager').TokenManagerConfig = {\n      baseUrl: config.baseUrl,\n      storage: this.storage,\n      refreshThreshold: config.auth?.refreshThreshold ?? 60,\n      onTokenRefresh: (tokens) => {\n        this.stateManager.setTokenRefreshed(tokens);\n        config.auth?.onAuthStateChange?.(this.stateManager.getState());\n      },\n      onSessionExpired: (error) => {\n        this.stateManager.setSessionExpired(error);\n        config.auth?.onAuthError?.(error);\n      },\n      onTokenReuseDetected: () => {\n        config.auth?.onAuthError?.(\n          new AuthenticationError(\n            'Security breach detected. Session invalidated.',\n            'TOKEN_REUSE_DETECTED'\n          )\n        );\n      },\n    };\n    if (config.apiKey) {\n      tokenManagerConfig.apiKey = config.apiKey;\n    }\n    this.tokenManager = new TokenManager(tokenManagerConfig);\n\n    // Initialize mode-specific components\n    if (this.mode === 'redirect' && config.auth?.callbackUrl) {\n      this.redirectMode = new RedirectMode({\n        baseUrl: config.baseUrl,\n        appSlug: config.appSlug,\n        callbackUrl: config.auth.callbackUrl,\n        storage: this.storage,\n        // Pass storageMode to signal backend to use cookies - @task TASK-500, @feature FTR-109\n        storageMode: config.auth?.storage === 'cookie' ? 'cookie' : 'bearer',\n      });\n\n      // apiKey is optional for redirect mode callback handling (TASK-501)\n      const callbackConfig: import('./callback').CallbackConfig = {\n        baseUrl: config.baseUrl,\n        appSlug: config.appSlug,\n        callbackUrl: config.auth.callbackUrl,\n        storage: this.storage,\n      };\n      if (config.apiKey) {\n        callbackConfig.apiKey = config.apiKey;\n      }\n      this.callbackHandler = new CallbackHandler(callbackConfig);\n    } else if (this.mode === 'embedded') {\n      // apiKey is optional for embedded mode (TASK-501)\n      const embeddedConfig: import('./embedded').EmbeddedModeConfig = {\n        baseUrl: config.baseUrl,\n        appSlug: config.appSlug,\n        storage: this.storage,\n      };\n      if (config.apiKey) {\n        embeddedConfig.apiKey = config.apiKey;\n      }\n      this.embeddedMode = new EmbeddedMode(embeddedConfig);\n    }\n  }\n\n  /**\n   * Initialize auth state from storage.\n   * Call this on app startup.\n   */\n  async initialize(): Promise<void> {\n    await this.stateManager.initialize();\n\n    // Start auto-refresh if authenticated and enabled\n    if (this.stateManager.isAuthenticated() && this.config.auth?.autoRefresh !== false) {\n      await this.tokenManager.startAutoRefresh();\n    }\n  }\n\n  /**\n   * Get current auth state.\n   */\n  getState(): AuthState {\n    return this.stateManager.getState();\n  }\n\n  /**\n   * Get current user.\n   */\n  getUser(): AuthUser | null {\n    return this.stateManager.getUser();\n  }\n\n  /**\n   * Check if authenticated.\n   */\n  isAuthenticated(): boolean {\n    return this.stateManager.isAuthenticated();\n  }\n\n  /**\n   * Subscribe to auth state changes.\n   */\n  onStateChange(callback: (state: AuthState) => void): () => void {\n    return this.stateManager.onStateChange(callback);\n  }\n\n  /**\n   * Log in.\n   * In redirect mode: redirects to AuthHub portal\n   * In embedded mode: authenticates with credentials\n   */\n  async login(\n    credentials?: LoginCredentials,\n    options?: RedirectLoginOptions\n  ): Promise<LoginResult | void> {\n    if (this.mode === 'redirect' && this.redirectMode) {\n      await this.redirectMode.login(options);\n      return;\n    }\n\n    if (this.mode === 'embedded' && this.embeddedMode) {\n      if (!credentials) {\n        throw new Error('Credentials required for embedded mode');\n      }\n      const result = await this.embeddedMode.login(credentials);\n      if (result.success && result.user) {\n        const tokens = await this.storage.getTokens();\n        if (tokens) {\n          this.stateManager.setSignedIn(result.user, tokens);\n          if (this.config.auth?.autoRefresh !== false) {\n            await this.tokenManager.startAutoRefresh();\n          }\n        }\n      }\n      return result;\n    }\n\n    throw new Error(`Login not available in ${this.mode} mode`);\n  }\n\n  /**\n   * Register a new user.\n   */\n  async register(data: RegisterData): Promise<RegisterResult> {\n    if (this.mode === 'redirect' && this.redirectMode) {\n      const registerOptions: import('./redirect').RegisterRedirectOptions = { email: data.email };\n      if (data.name) {\n        registerOptions.name = data.name;\n      }\n      await this.redirectMode.register(registerOptions);\n      return { success: true };\n    }\n\n    if (this.mode === 'embedded' && this.embeddedMode) {\n      return this.embeddedMode.register(data);\n    }\n\n    throw new Error(`Register not available in ${this.mode} mode`);\n  }\n\n  /**\n   * Log out.\n   */\n  async logout(): Promise<void> {\n    this.tokenManager.stopAutoRefresh();\n\n    if (this.mode === 'redirect' && this.redirectMode) {\n      await this.redirectMode.logout();\n    } else if (this.mode === 'embedded' && this.embeddedMode) {\n      await this.embeddedMode.logout();\n    } else {\n      await this.storage.clearTokens();\n    }\n\n    this.stateManager.setSignedOut();\n  }\n\n  /**\n   * Handle OAuth callback (redirect mode only).\n   */\n  async handleCallback(url?: string): Promise<LoginResult> {\n    if (!this.callbackHandler) {\n      throw new Error('Callback handler not available (redirect mode required)');\n    }\n\n    const result = await this.callbackHandler.handleCallback(url);\n\n    if (result.success && result.user) {\n      const tokens = await this.storage.getTokens();\n      if (tokens) {\n        this.stateManager.setSignedIn(result.user, tokens);\n        if (this.config.auth?.autoRefresh !== false) {\n          await this.tokenManager.startAutoRefresh();\n        }\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Check if current URL is a callback.\n   */\n  isCallback(): boolean {\n    if (typeof window === 'undefined') return false;\n    const params = new URLSearchParams(window.location.search);\n    return params.has('code') || params.has('error');\n  }\n\n  /**\n   * Refresh the current token.\n   */\n  async refreshToken(): Promise<RefreshResult> {\n    return this.tokenManager.refreshToken();\n  }\n\n  /**\n   * Get a valid access token.\n   *\n   * In cookie mode, returns null since tokens are stored in httpOnly cookies\n   * and cannot be accessed by JavaScript. Use `credentials: 'include'` in\n   * fetch requests to have the browser automatically include cookies.\n   *\n   * @returns Access token or null (null in cookie mode by design)\n   */\n  async getAccessToken(): Promise<string | null> {\n    // In cookie mode, tokens are in httpOnly cookies - not accessible to JS\n    if (this.config.auth?.storage === 'cookie') {\n      // Dev-mode warning to help developers understand cookie mode behavior\n      if (typeof process !== 'undefined' && process.env?.['NODE_ENV'] !== 'production') {\n        console.warn(\n          '[AuthHub SDK] getAccessToken() returns null in cookie mode. ' +\n          'This is expected behavior - tokens are stored in httpOnly cookies. ' +\n          'Use `credentials: \"include\"` in fetch requests, or use isCookieMode() ' +\n          'to check the storage mode before calling getAccessToken().'\n        );\n      }\n      return null;\n    }\n    return this.tokenManager.getValidToken();\n  }\n\n  /**\n   * Check if the SDK is configured to use cookie mode.\n   * When true, API requests should use `credentials: 'include'`.\n   *\n   * @returns True if using cookie storage mode\n   */\n  isCookieMode(): boolean {\n    return this.config.auth?.storage === 'cookie';\n  }\n\n  /**\n   * Request password reset (embedded mode).\n   */\n  async requestPasswordReset(email: string): Promise<PasswordResetResult> {\n    if (!this.embeddedMode) {\n      throw new Error('Password reset requires embedded mode');\n    }\n    return this.embeddedMode.forgotPassword(email);\n  }\n\n  /**\n   * Reset password with token (embedded mode).\n   */\n  async resetPassword(token: string, newPassword: string): Promise<PasswordResetResult> {\n    if (!this.embeddedMode) {\n      throw new Error('Password reset requires embedded mode');\n    }\n    return this.embeddedMode.resetPassword(token, newPassword);\n  }\n\n  /**\n   * Create an auth-only client without API key.\n   *\n   * Use this factory method when you only need authentication functionality\n   * (redirect-mode login, logout, session management) and don't need access\n   * to protected operations (AI, Database, Secrets).\n   *\n   * @param config - Configuration without apiKey\n   * @returns AuthClient instance configured for auth-only usage\n   *\n   * @example\n   * ```typescript\n   * // Auth-only client for redirect-mode authentication\n   * const auth = AuthClient.forAuth({\n   *   baseUrl: 'https://authhub.example.com',\n   *   appSlug: 'my-app',\n   *   auth: {\n   *     mode: 'redirect',\n   *     callbackUrl: 'https://myapp.com/auth/callback',\n   *   },\n   * });\n   *\n   * // Login (redirects to AuthHub portal)\n   * await auth.login();\n   * ```\n   *\n   * @task TASK-501\n   * @feature FTR-110\n   */\n  static forAuth(config: Omit<AuthClientConfig, 'apiKey'>): AuthClient {\n    return new AuthClient(config);\n  }\n}\n\n/**\n * Create an auth client with configuration.\n */\nexport function createAuthClient(config: AuthClientConfig): AuthClient {\n  return new AuthClient(config);\n}\n","/**\n * AuthHub SDK OAuth Methods\n *\n * OAuth URL generation and callback parsing for third-party authentication.\n *\n * @module @authhub/sdk/auth/oauth\n * @task TASK-461\n * @feature OAuth SDK Methods and Dashboard Integration\n */\n\n// ============================================================================\n// Types\n// ============================================================================\n\n/**\n * Supported OAuth providers.\n */\nexport enum OAuthProvider {\n  Google = 'google',\n  GitHub = 'github',\n}\n\n/**\n * Options for generating OAuth URLs.\n */\nexport interface OAuthUrlOptions {\n  /**\n   * Optional state parameter for CSRF protection.\n   * If not provided, you should generate one client-side.\n   */\n  state?: string;\n\n  /**\n   * Optional scope override.\n   * Defaults to provider-specific scopes configured in AuthHub.\n   */\n  scope?: string;\n\n  /**\n   * Optional prompt parameter for Google OAuth.\n   * - 'none': No prompt\n   * - 'consent': Force consent screen\n   * - 'select_account': Force account selection\n   */\n  prompt?: 'none' | 'consent' | 'select_account';\n}\n\n/**\n * Result of parsing an OAuth callback URL.\n */\nexport interface OAuthCallbackResult {\n  /** Access token (implicit flow) */\n  accessToken?: string;\n\n  /** Refresh token (if provided) */\n  refreshToken?: string;\n\n  /** Token type (usually 'Bearer') */\n  tokenType?: string;\n\n  /** Token expiration in seconds */\n  expiresIn?: number;\n\n  /** State parameter for CSRF validation */\n  state?: string;\n\n  /** Authorization code (authorization code flow) */\n  code?: string;\n\n  /** Error code */\n  error?: string;\n\n  /** Error description */\n  errorDescription?: string;\n}\n\n// ============================================================================\n// URL Generation Functions\n// ============================================================================\n\n/**\n * Build OAuth URL base with common parameters.\n *\n * @param baseUrl - AuthHub API base URL\n * @param provider - OAuth provider\n * @param appId - Application ID\n * @param redirectUri - Redirect URI after OAuth\n * @param options - Additional options\n * @returns OAuth URL\n * @internal\n */\nfunction buildOAuthUrl(\n  baseUrl: string,\n  provider: OAuthProvider,\n  appId: string,\n  redirectUri: string,\n  options?: OAuthUrlOptions\n): string {\n  // Normalize base URL (remove trailing slash)\n  const normalizedBaseUrl = baseUrl.replace(/\\/$/, '');\n\n  const params = new URLSearchParams();\n  params.set('redirect_uri', redirectUri);\n  params.set('app_id', appId);\n\n  if (options?.state) {\n    params.set('state', options.state);\n  }\n\n  if (options?.scope) {\n    params.set('scope', options.scope);\n  }\n\n  if (options?.prompt) {\n    params.set('prompt', options.prompt);\n  }\n\n  return `${normalizedBaseUrl}/api/v1/auth/oauth/${provider}?${params.toString()}`;\n}\n\n/**\n * Generate Google OAuth authorization URL.\n *\n * @param baseUrl - AuthHub API base URL\n * @param appId - Application ID registered with AuthHub\n * @param redirectUri - URL to redirect to after OAuth (must be registered)\n * @param options - Additional OAuth options\n * @returns Google OAuth authorization URL\n *\n * @example\n * ```typescript\n * const url = getGoogleAuthUrl(\n *   'https://authhub.example.com',\n *   'app_abc123',\n *   'https://myapp.com/auth/callback'\n * );\n * window.location.href = url;\n * ```\n */\nexport function getGoogleAuthUrl(\n  baseUrl: string,\n  appId: string,\n  redirectUri: string,\n  options?: OAuthUrlOptions\n): string {\n  return buildOAuthUrl(baseUrl, OAuthProvider.Google, appId, redirectUri, options);\n}\n\n/**\n * Generate GitHub OAuth authorization URL.\n *\n * @param baseUrl - AuthHub API base URL\n * @param appId - Application ID registered with AuthHub\n * @param redirectUri - URL to redirect to after OAuth (must be registered)\n * @param options - Additional OAuth options\n * @returns GitHub OAuth authorization URL\n *\n * @example\n * ```typescript\n * const url = getGitHubAuthUrl(\n *   'https://authhub.example.com',\n *   'app_abc123',\n *   'https://myapp.com/auth/callback'\n * );\n * window.location.href = url;\n * ```\n */\nexport function getGitHubAuthUrl(\n  baseUrl: string,\n  appId: string,\n  redirectUri: string,\n  options?: OAuthUrlOptions\n): string {\n  return buildOAuthUrl(baseUrl, OAuthProvider.GitHub, appId, redirectUri, options);\n}\n\n/**\n * Generate OAuth authorization URL for a specific provider.\n *\n * @param baseUrl - AuthHub API base URL\n * @param provider - OAuth provider\n * @param appId - Application ID registered with AuthHub\n * @param redirectUri - URL to redirect to after OAuth (must be registered)\n * @param options - Additional OAuth options\n * @returns OAuth authorization URL\n *\n * @example\n * ```typescript\n * const url = getOAuthUrl(\n *   'https://authhub.example.com',\n *   OAuthProvider.Google,\n *   'app_abc123',\n *   'https://myapp.com/auth/callback',\n *   { state: 'random_state_value' }\n * );\n * ```\n */\nexport function getOAuthUrl(\n  baseUrl: string,\n  provider: OAuthProvider,\n  appId: string,\n  redirectUri: string,\n  options?: OAuthUrlOptions\n): string {\n  return buildOAuthUrl(baseUrl, provider, appId, redirectUri, options);\n}\n\n// ============================================================================\n// Callback Parsing Functions\n// ============================================================================\n\n/**\n * Parse OAuth callback result from URL.\n *\n * Handles both implicit flow (tokens in hash fragment) and\n * authorization code flow (code in query parameters).\n *\n * @param url - Callback URL to parse\n * @returns Parsed callback result or null if no OAuth parameters found\n *\n * @example\n * ```typescript\n * // Implicit flow (hash fragment)\n * const result = parseOAuthCallbackResult(\n *   'https://myapp.com/callback#access_token=abc123&token_type=Bearer'\n * );\n * if (result?.accessToken) {\n *   // Use token\n * }\n *\n * // Authorization code flow (query params)\n * const result = parseOAuthCallbackResult(\n *   'https://myapp.com/callback?code=auth_code_123&state=xyz'\n * );\n * if (result?.code) {\n *   // Exchange code for tokens\n * }\n *\n * // Error handling\n * const result = parseOAuthCallbackResult(\n *   'https://myapp.com/callback?error=access_denied&error_description=User%20denied'\n * );\n * if (result?.error) {\n *   console.error(result.errorDescription);\n * }\n * ```\n */\nexport function parseOAuthCallbackResult(url: string): OAuthCallbackResult | null {\n  let urlObj: URL;\n  try {\n    urlObj = new URL(url);\n  } catch {\n    return null;\n  }\n\n  const result: OAuthCallbackResult = {};\n  let hasParams = false;\n\n  // First, check hash fragment (implicit flow takes precedence)\n  const hash = urlObj.hash.slice(1); // Remove leading #\n  if (hash) {\n    const hashParams = new URLSearchParams(hash);\n\n    const accessToken = hashParams.get('access_token');\n    if (accessToken) {\n      result.accessToken = accessToken;\n      hasParams = true;\n    }\n\n    const refreshToken = hashParams.get('refresh_token');\n    if (refreshToken) {\n      result.refreshToken = refreshToken;\n      hasParams = true;\n    }\n\n    const tokenType = hashParams.get('token_type');\n    if (tokenType) {\n      result.tokenType = tokenType;\n      hasParams = true;\n    }\n\n    const expiresIn = hashParams.get('expires_in');\n    if (expiresIn) {\n      const parsed = parseInt(expiresIn, 10);\n      if (!isNaN(parsed)) {\n        result.expiresIn = parsed;\n        hasParams = true;\n      }\n    }\n\n    const state = hashParams.get('state');\n    if (state) {\n      result.state = state;\n      hasParams = true;\n    }\n\n    const error = hashParams.get('error');\n    if (error) {\n      result.error = error;\n      hasParams = true;\n    }\n\n    const errorDescription = hashParams.get('error_description');\n    if (errorDescription) {\n      result.errorDescription = errorDescription;\n      hasParams = true;\n    }\n  }\n\n  // Then check query parameters (authorization code flow)\n  // Only add if not already found in hash\n  const searchParams = urlObj.searchParams;\n\n  const code = searchParams.get('code');\n  if (code && !result.accessToken) {\n    result.code = code;\n    hasParams = true;\n  }\n\n  const state = searchParams.get('state');\n  if (state && !result.state) {\n    result.state = state;\n    hasParams = true;\n  }\n\n  const error = searchParams.get('error');\n  if (error && !result.error) {\n    result.error = error;\n    hasParams = true;\n  }\n\n  const errorDescription = searchParams.get('error_description');\n  if (errorDescription && !result.errorDescription) {\n    result.errorDescription = errorDescription;\n    hasParams = true;\n  }\n\n  return hasParams ? result : null;\n}\n\n/**\n * Check if a URL contains OAuth callback parameters.\n *\n * @param url - URL to check\n * @returns True if URL contains OAuth callback parameters\n */\nexport function hasOAuthCallback(url: string): boolean {\n  const result = parseOAuthCallbackResult(url);\n  return result !== null && (\n    Boolean(result.accessToken) ||\n    Boolean(result.code) ||\n    Boolean(result.error)\n  );\n}\n\n/**\n * Check if a URL contains an OAuth error.\n *\n * @param url - URL to check\n * @returns True if URL contains OAuth error\n */\nexport function hasOAuthError(url: string): boolean {\n  const result = parseOAuthCallbackResult(url);\n  return result !== null && Boolean(result.error);\n}\n\n/**\n * Extract OAuth error details from URL.\n *\n * @param url - URL to parse\n * @returns Error details or null if no error\n */\nexport function getOAuthError(url: string): { error: string; description?: string } | null {\n  const result = parseOAuthCallbackResult(url);\n  if (!result?.error) {\n    return null;\n  }\n\n  const errorResult: { error: string; description?: string } = {\n    error: result.error,\n  };\n\n  if (result.errorDescription) {\n    errorResult.description = result.errorDescription;\n  }\n\n  return errorResult;\n}\n","/**\r\n * AuthHub AI Module\r\n *\r\n * Provides AI chat completion, image generation, embeddings,\r\n * audio transcription, and text-to-speech capabilities through the AuthHub proxy.\r\n *\r\n * @module @authhub/sdk/ai\r\n * @task TASK-521, TASK-526, TASK-531, TASK-536\r\n * @feature FTR-112, FTR-113, FTR-114, FTR-115\r\n */\r\n\r\nimport type {\r\n  ChatCompletionOptions,\r\n  ChatCompletionResponse,\r\n  ChatStreamChunk,\r\n  ListModelsResponse,\r\n  ListModelsOptions,\r\n  AIUsageStats,\r\n  GetUsageOptions,\r\n  // Image generation types (FTR-112)\r\n  ImageGenerationOptions,\r\n  ImageGenerationResponse,\r\n  // Embedding types (FTR-113)\r\n  EmbeddingOptions,\r\n  EmbeddingResponse,\r\n  // Transcription types (FTR-114)\r\n  TranscriptionOptions,\r\n  TranscriptionResponse,\r\n  // Speech types (FTR-115)\r\n  SpeechOptions,\r\n} from '../types';\r\n\r\n/**\r\n * Request function type for making authenticated API calls.\r\n */\r\ntype RequestFn = <T>(options: {\r\n  method: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';\r\n  path: string;\r\n  body?: unknown;\r\n  params?: Record<string, string | number | boolean | undefined>;\r\n}) => Promise<T>;\r\n\r\n/**\r\n * Configuration for the AI module.\r\n */\r\ninterface AIModuleConfig {\r\n  request: RequestFn;\r\n  baseUrl: string;\r\n  apiKey: string;\r\n  timeout: number;\r\n}\r\n\r\n/**\r\n * AI module for chat completions, image generation, embeddings,\r\n * audio transcription, and text-to-speech.\r\n *\r\n * @example\r\n * ```typescript\r\n * // Chat completion\r\n * const response = await client.ai.chat({\r\n *   model: 'gpt-4',\r\n *   messages: [{ role: 'user', content: 'Hello!' }],\r\n * });\r\n * console.log(response.choices[0].message.content);\r\n *\r\n * // Image generation\r\n * const images = await client.ai.generateImage({\r\n *   prompt: 'A beautiful sunset',\r\n *   model: 'nano-banana-pro',\r\n * });\r\n *\r\n * // Embeddings\r\n * const embeddings = await client.ai.createEmbedding({\r\n *   input: 'Hello world',\r\n * });\r\n *\r\n * // Transcription\r\n * const transcript = await client.ai.transcribe({\r\n *   file: audioBlob,\r\n * });\r\n *\r\n * // Text-to-speech\r\n * const audio = await client.ai.speak({\r\n *   input: 'Hello!',\r\n *   voice: 'nova',\r\n * });\r\n * ```\r\n */\r\nexport class AIModule {\r\n  private readonly config: AIModuleConfig;\r\n\r\n  /**\r\n   * Creates a new AI module instance.\r\n   * @internal\r\n   */\r\n  constructor(config: AIModuleConfig) {\r\n    this.config = config;\r\n  }\r\n\r\n  /**\r\n   * Send a chat completion request.\r\n   *\r\n   * @param options - Chat completion options (model, messages, etc.)\r\n   * @returns Chat completion response with choices and usage\r\n   * @throws {Error} If the request fails\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const response = await client.ai.chat({\r\n   *   model: 'gpt-4',\r\n   *   messages: [\r\n   *     { role: 'system', content: 'You are a helpful assistant.' },\r\n   *     { role: 'user', content: 'What is TypeScript?' },\r\n   *   ],\r\n   *   temperature: 0.7,\r\n   *   max_tokens: 500,\r\n   * });\r\n   *\r\n   * console.log(response.choices[0].message.content);\r\n   * console.log(`Tokens used: ${response.usage.total_tokens}`);\r\n   * ```\r\n   */\r\n  async chat(options: ChatCompletionOptions): Promise<ChatCompletionResponse> {\r\n    this.validateChatOptions(options);\r\n\r\n    const response = await this.config.request<ChatCompletionResponse>({\r\n      method: 'POST',\r\n      path: '/api/v1/ai/chat/completions',\r\n      body: {\r\n        ...options,\r\n        stream: false,\r\n      },\r\n    });\r\n\r\n    return response;\r\n  }\r\n\r\n  /**\r\n   * Send a streaming chat completion request.\r\n   *\r\n   * @param options - Chat completion options (model, messages, etc.)\r\n   * @returns Async iterator yielding chat chunks\r\n   * @throws {Error} If the request fails\r\n   *\r\n   * @remarks\r\n   * **Timeout Behavior**: The configured timeout applies only to the initial\r\n   * connection. Once streaming begins, there is no per-chunk timeout. For\r\n   * very long responses, the stream will continue until completion or error.\r\n   *\r\n   * If you need to limit total streaming time, implement your own timeout\r\n   * logic wrapping the async iterator, or use `AbortController`:\r\n   *\r\n   * ```typescript\r\n   * const controller = new AbortController();\r\n   * setTimeout(() => controller.abort(), 120000); // 2 min max\r\n   *\r\n   * try {\r\n   *   for await (const chunk of client.ai.chatStream(options)) {\r\n   *     // Process chunk\r\n   *   }\r\n   * } catch (e) {\r\n   *   if (e.name === 'AbortError') console.log('Stream timed out');\r\n   * }\r\n   * ```\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const stream = client.ai.chatStream({\r\n   *   model: 'gpt-4',\r\n   *   messages: [{ role: 'user', content: 'Tell me a story.' }],\r\n   * });\r\n   *\r\n   * for await (const chunk of stream) {\r\n   *   process.stdout.write(chunk.content);\r\n   *   if (chunk.finish_reason) {\r\n   *     console.log('\\n--- Stream complete ---');\r\n   *   }\r\n   * }\r\n   * ```\r\n   */\r\n  async *chatStream(\r\n    options: ChatCompletionOptions\r\n  ): AsyncGenerator<ChatStreamChunk, void, undefined> {\r\n    this.validateChatOptions(options);\r\n\r\n    const url = new URL('/api/v1/ai/chat/completions', this.config.baseUrl);\r\n\r\n    // SECURITY NOTE: API key is included in headers for streaming requests.\r\n    // Ensure request headers are not logged in production environments.\r\n    const headers: Record<string, string> = {\r\n      'X-API-Key': this.config.apiKey,\r\n      'Content-Type': 'application/json',\r\n      'Accept': 'text/event-stream',\r\n    };\r\n\r\n    const controller = new AbortController();\r\n    // NOTE: This timeout only applies to the initial connection.\r\n    // Once streaming begins, chunks can take any amount of time.\r\n    // See the @remarks section above for implementing custom streaming timeouts.\r\n    const timeoutId = setTimeout(\r\n      () => controller.abort(),\r\n      this.config.timeout\r\n    );\r\n\r\n    try {\r\n      const response = await fetch(url.toString(), {\r\n        method: 'POST',\r\n        headers,\r\n        body: JSON.stringify({\r\n          ...options,\r\n          stream: true,\r\n        }),\r\n        signal: controller.signal,\r\n      });\r\n\r\n      clearTimeout(timeoutId);\r\n\r\n      if (!response.ok) {\r\n        const errorBody = await response.json().catch(() => ({})) as Record<string, unknown>;\r\n        const message = this.extractErrorMessage(errorBody, response.status);\r\n        throw new Error(message);\r\n      }\r\n\r\n      if (!response.body) {\r\n        throw new Error('Response body is null');\r\n      }\r\n\r\n      const reader = response.body.getReader();\r\n      const decoder = new TextDecoder();\r\n      let buffer = '';\r\n\r\n      while (true) {\r\n        const { done, value } = await reader.read();\r\n\r\n        if (done) {\r\n          break;\r\n        }\r\n\r\n        buffer += decoder.decode(value, { stream: true });\r\n        const lines = buffer.split('\\n');\r\n        buffer = lines.pop() ?? '';\r\n\r\n        for (const line of lines) {\r\n          const trimmed = line.trim();\r\n\r\n          if (!trimmed || trimmed.startsWith(':')) {\r\n            continue;\r\n          }\r\n\r\n          if (trimmed === 'data: [DONE]') {\r\n            return;\r\n          }\r\n\r\n          if (trimmed.startsWith('data: ')) {\r\n            const json = trimmed.slice(6);\r\n            try {\r\n              const data = JSON.parse(json) as StreamChunkData;\r\n              const delta = data.choices?.[0]?.delta;\r\n\r\n              if (delta?.content !== undefined) {\r\n                yield {\r\n                  content: delta.content,\r\n                  finish_reason: data.choices?.[0]?.finish_reason ?? null,\r\n                };\r\n              } else if (data.choices?.[0]?.finish_reason) {\r\n                yield {\r\n                  content: '',\r\n                  finish_reason: data.choices[0].finish_reason,\r\n                };\r\n              }\r\n            } catch {\r\n              // Ignore malformed JSON chunks\r\n            }\r\n          }\r\n        }\r\n      }\r\n    } catch (error) {\r\n      clearTimeout(timeoutId);\r\n      if (error instanceof Error && error.name === 'AbortError') {\r\n        throw new Error(`Stream timed out after ${this.config.timeout}ms`);\r\n      }\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * List available AI models.\r\n   *\r\n   * Returns models from all configured providers for this app.\r\n   * Use this to discover which models are available rather than hardcoding.\r\n   *\r\n   * @returns List of available AI models with pricing and capabilities\r\n   * @throws {Error} If the request fails\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const { data: models } = await client.ai.listModels();\r\n   *\r\n   * // Display available models\r\n   * models.forEach((model) => {\r\n   *   console.log(`${model.id} (${model.owned_by})`);\r\n   *   if (model.context_window) {\r\n   *     console.log(`  Context: ${model.context_window} tokens`);\r\n   *   }\r\n   * });\r\n   *\r\n   * // Find models by provider\r\n   * const openaiModels = models.filter((m) => m.owned_by === 'openai');\r\n   *\r\n   * // Get only text-output models (excludes image, video, audio generators)\r\n   * const { data: chatModels } = await client.ai.listModels({\r\n   *   output_modality: 'text',\r\n   * });\r\n   *\r\n   * // Get models that accept images as input (vision models)\r\n   * const { data: visionModels } = await client.ai.listModels({\r\n   *   input_modality: 'image',\r\n   * });\r\n   * ```\r\n   */\r\n  async listModels(options?: ListModelsOptions): Promise<ListModelsResponse> {\r\n    const params: Record<string, string | undefined> = {};\r\n\r\n    if (options?.output_modality) {\r\n      params['output_modality'] = options.output_modality;\r\n    }\r\n    if (options?.input_modality) {\r\n      params['input_modality'] = options.input_modality;\r\n    }\r\n\r\n    return this.config.request<ListModelsResponse>({\r\n      method: 'GET',\r\n      path: '/api/v1/ai/models',\r\n      params,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get AI usage statistics for your app.\r\n   *\r\n   * Returns usage metrics including request counts, token consumption,\r\n   * and cost estimates broken down by provider and over time.\r\n   *\r\n   * @param options - Query options for date range and grouping\r\n   * @returns Usage statistics with totals, by-provider breakdown, and timeline\r\n   * @throws {Error} If the request fails\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * // Get usage for the last 30 days\r\n   * const usage = await client.ai.getUsage({\r\n   *   startDate: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000),\r\n   *   endDate: new Date(),\r\n   *   groupBy: 'day',\r\n   * });\r\n   *\r\n   * console.log(`Total requests: ${usage.totals.requests}`);\r\n   * console.log(`Total cost: $${usage.totals.cost.toFixed(2)}`);\r\n   *\r\n   * // Show usage by provider\r\n   * for (const [provider, stats] of Object.entries(usage.byProvider)) {\r\n   *   console.log(`${provider}: ${stats.requests} requests, $${stats.cost.toFixed(2)}`);\r\n   * }\r\n   * ```\r\n   */\r\n  async getUsage(options?: GetUsageOptions): Promise<AIUsageStats> {\r\n    const params: Record<string, string | undefined> = {};\r\n\r\n    if (options?.startDate) {\r\n      params['startDate'] = options.startDate.toISOString();\r\n    }\r\n    if (options?.endDate) {\r\n      params['endDate'] = options.endDate.toISOString();\r\n    }\r\n    if (options?.groupBy) {\r\n      params['groupBy'] = options.groupBy;\r\n    }\r\n\r\n    const response = await this.config.request<{ success: boolean; data: AIUsageStats }>({\r\n      method: 'GET',\r\n      path: '/api/v1/ai/usage',\r\n      params,\r\n    });\r\n\r\n    return response.data;\r\n  }\r\n\r\n  // ============================================================================\r\n  // Image Generation (FTR-112)\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Generate images from text prompts.\r\n   *\r\n   * @param options - Image generation options\r\n   * @returns Generated images with URLs or base64 data\r\n   * @throws {Error} If the request fails\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const result = await client.ai.generateImage({\r\n   *   prompt: 'A beautiful sunset over mountains',\r\n   *   model: 'nano-banana-pro', // default\r\n   *   aspect_ratio: '16:9',\r\n   *   n: 1,\r\n   * });\r\n   *\r\n   * // Access generated image URL\r\n   * console.log(result.data[0].url);\r\n   *\r\n   * // Or base64 if response_format: 'b64_json'\r\n   * console.log(result.data[0].b64_json);\r\n   * ```\r\n   *\r\n   * @task TASK-521\r\n   * @feature FTR-112\r\n   */\r\n  async generateImage(options: ImageGenerationOptions): Promise<ImageGenerationResponse> {\r\n    this.validateImageOptions(options);\r\n\r\n    return this.config.request<ImageGenerationResponse>({\r\n      method: 'POST',\r\n      path: '/api/v1/ai/images/generations',\r\n      body: {\r\n        // Core parameters\r\n        model: options.model || 'nano-banana-pro',\r\n        prompt: options.prompt,\r\n        ...(options.n !== undefined && { n: options.n }),\r\n        ...(options.size !== undefined && { size: options.size }),\r\n        ...(options.aspect_ratio !== undefined && { aspect_ratio: options.aspect_ratio }),\r\n        ...(options.quality !== undefined && { quality: options.quality }),\r\n        ...(options.style !== undefined && { style: options.style }),\r\n        ...(options.response_format !== undefined && { response_format: options.response_format }),\r\n        ...(options.user !== undefined && { user: options.user }),\r\n\r\n        // Universal advanced parameters\r\n        ...(options.seed !== undefined && { seed: options.seed }),\r\n        ...(options.negative_prompt !== undefined && { negative_prompt: options.negative_prompt }),\r\n        ...(options.output_format !== undefined && { output_format: options.output_format }),\r\n\r\n        // OpenAI GPT-Image parameters\r\n        ...(options.background !== undefined && { background: options.background }),\r\n        ...(options.output_compression !== undefined && { output_compression: options.output_compression }),\r\n        ...(options.moderation !== undefined && { moderation: options.moderation }),\r\n        ...(options.fidelity !== undefined && { fidelity: options.fidelity }),\r\n\r\n        // Image editing parameters\r\n        ...(options.image !== undefined && { image: options.image }),\r\n        ...(options.mask !== undefined && { mask: options.mask }),\r\n\r\n        // Diffusion model parameters\r\n        ...(options.guidance_scale !== undefined && { guidance_scale: options.guidance_scale }),\r\n        ...(options.num_inference_steps !== undefined && { num_inference_steps: options.num_inference_steps }),\r\n        ...(options.scheduler !== undefined && { scheduler: options.scheduler }),\r\n        ...(options.style_preset !== undefined && { style_preset: options.style_preset }),\r\n\r\n        // Google Imagen/Gemini parameters\r\n        ...(options.language !== undefined && { language: options.language }),\r\n        ...(options.enhance_prompt !== undefined && { enhance_prompt: options.enhance_prompt }),\r\n        ...(options.person_generation !== undefined && { person_generation: options.person_generation }),\r\n        ...(options.safety_setting !== undefined && { safety_setting: options.safety_setting }),\r\n        ...(options.add_watermark !== undefined && { add_watermark: options.add_watermark }),\r\n\r\n        // Nano Banana Pro exclusive parameters\r\n        ...(options.thinking !== undefined && { thinking: options.thinking }),\r\n        ...(options.search_grounding !== undefined && { search_grounding: options.search_grounding }),\r\n        ...(options.reference_images !== undefined && { reference_images: options.reference_images }),\r\n      },\r\n    });\r\n  }\r\n\r\n  // ============================================================================\r\n  // Embeddings (FTR-113)\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Create embeddings for text input.\r\n   *\r\n   * @param options - Embedding options\r\n   * @returns Embedding vectors for the input\r\n   * @throws {Error} If the request fails\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * // Single embedding\r\n   * const result = await client.ai.createEmbedding({\r\n   *   model: 'text-embedding-3-small',\r\n   *   input: 'Hello world',\r\n   * });\r\n   * console.log(result.data[0].embedding.length); // 1536\r\n   *\r\n   * // Batch embeddings\r\n   * const result = await client.ai.createEmbedding({\r\n   *   input: ['Hello', 'World', 'Test'],\r\n   * });\r\n   * ```\r\n   *\r\n   * @task TASK-526\r\n   * @feature FTR-113\r\n   */\r\n  async createEmbedding(options: EmbeddingOptions): Promise<EmbeddingResponse> {\r\n    this.validateEmbeddingOptions(options);\r\n\r\n    return this.config.request<EmbeddingResponse>({\r\n      method: 'POST',\r\n      path: '/api/v1/ai/embeddings',\r\n      body: {\r\n        model: options.model || 'text-embedding-3-small',\r\n        input: options.input,\r\n        ...(options.encoding_format !== undefined && { encoding_format: options.encoding_format }),\r\n        ...(options.dimensions !== undefined && { dimensions: options.dimensions }),\r\n        ...(options.user !== undefined && { user: options.user }),\r\n      },\r\n    });\r\n  }\r\n\r\n  // ============================================================================\r\n  // Audio Transcription (FTR-114)\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Transcribe audio to text.\r\n   *\r\n   * @param options - Transcription options including audio file\r\n   * @returns Transcribed text and optional timing information\r\n   * @throws {Error} If the request fails\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * // Browser usage\r\n   * const result = await client.ai.transcribe({\r\n   *   file: audioBlob,\r\n   *   language: 'en',\r\n   * });\r\n   * console.log(result.text);\r\n   *\r\n   * // Node.js with file buffer\r\n   * const audioBuffer = fs.readFileSync('audio.mp3');\r\n   * const result = await client.ai.transcribe({\r\n   *   file: audioBuffer,\r\n   *   model: 'whisper-1',\r\n   *   response_format: 'verbose_json',\r\n   * });\r\n   * console.log(result.words); // Word-level timing\r\n   * ```\r\n   *\r\n   * @task TASK-531\r\n   * @feature FTR-114\r\n   */\r\n  async transcribe(options: TranscriptionOptions): Promise<TranscriptionResponse> {\r\n    this.validateTranscriptionOptions(options);\r\n\r\n    // Build FormData for multipart upload\r\n    const formData = new FormData();\r\n\r\n    // Handle different file input types\r\n    const filename = options.filename || 'audio.mp3';\r\n    let fileBlob: Blob;\r\n\r\n    if (options.file instanceof Blob) {\r\n      fileBlob = options.file;\r\n    } else if (options.file instanceof ArrayBuffer) {\r\n      // Use type assertion to satisfy strict TypeScript\r\n      fileBlob = new Blob([new Uint8Array(options.file) as BlobPart]);\r\n    } else if (typeof Buffer !== 'undefined' && Buffer.isBuffer(options.file)) {\r\n      // Node.js Buffer - slice to create a proper ArrayBuffer copy\r\n      const buf = options.file as Buffer;\r\n      const arrayBuffer = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length) as ArrayBuffer;\r\n      fileBlob = new Blob([new Uint8Array(arrayBuffer) as BlobPart]);\r\n    } else {\r\n      throw new Error('Unsupported file type. Use Blob, File, Buffer, or ArrayBuffer.');\r\n    }\r\n\r\n    formData.append('file', fileBlob, filename);\r\n\r\n    // Add other fields\r\n    formData.append('model', options.model || 'whisper-1');\r\n    if (options.language) formData.append('language', options.language);\r\n    if (options.prompt) formData.append('prompt', options.prompt);\r\n    if (options.response_format) formData.append('response_format', options.response_format);\r\n    if (options.temperature !== undefined) formData.append('temperature', String(options.temperature));\r\n\r\n    // Make request with FormData\r\n    const url = new URL('/api/v1/ai/audio/transcriptions', this.config.baseUrl);\r\n\r\n    const response = await fetch(url.toString(), {\r\n      method: 'POST',\r\n      headers: {\r\n        'X-API-Key': this.config.apiKey,\r\n      },\r\n      body: formData,\r\n    });\r\n\r\n    if (!response.ok) {\r\n      const errorBody = await response.json().catch(() => ({})) as Record<string, unknown>;\r\n      const message = this.extractErrorMessage(errorBody, response.status);\r\n      throw new Error(message);\r\n    }\r\n\r\n    return response.json() as Promise<TranscriptionResponse>;\r\n  }\r\n\r\n  // ============================================================================\r\n  // Text-to-Speech (FTR-115)\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Convert text to speech audio.\r\n   *\r\n   * @param options - Speech synthesis options\r\n   * @returns Audio data as ArrayBuffer\r\n   * @throws {Error} If the request fails\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const audio = await client.ai.speak({\r\n   *   model: 'tts-1',\r\n   *   input: 'Hello, this is a test.',\r\n   *   voice: 'nova',\r\n   *   response_format: 'mp3',\r\n   * });\r\n   *\r\n   * // Node.js: save to file\r\n   * fs.writeFileSync('output.mp3', Buffer.from(audio));\r\n   *\r\n   * // Browser: play audio\r\n   * const blob = new Blob([audio], { type: 'audio/mpeg' });\r\n   * const url = URL.createObjectURL(blob);\r\n   * new Audio(url).play();\r\n   * ```\r\n   *\r\n   * @task TASK-536\r\n   * @feature FTR-115\r\n   */\r\n  async speak(options: SpeechOptions): Promise<ArrayBuffer> {\r\n    this.validateSpeechOptions(options);\r\n\r\n    const url = new URL('/api/v1/ai/audio/speech', this.config.baseUrl);\r\n\r\n    const response = await fetch(url.toString(), {\r\n      method: 'POST',\r\n      headers: {\r\n        'X-API-Key': this.config.apiKey,\r\n        'Content-Type': 'application/json',\r\n      },\r\n      body: JSON.stringify({\r\n        model: options.model || 'tts-1',\r\n        input: options.input,\r\n        voice: options.voice,\r\n        ...(options.response_format !== undefined && { response_format: options.response_format }),\r\n        ...(options.speed !== undefined && { speed: options.speed }),\r\n      }),\r\n    });\r\n\r\n    if (!response.ok) {\r\n      const errorBody = await response.json().catch(() => ({})) as Record<string, unknown>;\r\n      const message = this.extractErrorMessage(errorBody, response.status);\r\n      throw new Error(message);\r\n    }\r\n\r\n    return response.arrayBuffer();\r\n  }\r\n\r\n  // ============================================================================\r\n  // Validation Methods\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Validate chat completion options.\r\n   * @internal\r\n   */\r\n  private validateChatOptions(options: ChatCompletionOptions): void {\r\n    if (!options.model) {\r\n      throw new Error('model is required');\r\n    }\r\n\r\n    if (!options.messages || !Array.isArray(options.messages)) {\r\n      throw new Error('messages must be an array');\r\n    }\r\n\r\n    if (options.messages.length === 0) {\r\n      throw new Error('messages cannot be empty');\r\n    }\r\n\r\n    for (const message of options.messages) {\r\n      if (!message.role || !['system', 'user', 'assistant'].includes(message.role)) {\r\n        throw new Error('each message must have a valid role (system, user, or assistant)');\r\n      }\r\n      if (typeof message.content !== 'string') {\r\n        throw new Error('each message must have a content string');\r\n      }\r\n    }\r\n\r\n    // Validate reasoning_effort if provided (for o1/o3/o4 models)\r\n    if (options.reasoning_effort !== undefined) {\r\n      const validEfforts = ['low', 'medium', 'high'];\r\n      if (!validEfforts.includes(options.reasoning_effort)) {\r\n        throw new Error('reasoning_effort must be: low, medium, or high');\r\n      }\r\n    }\r\n\r\n    // Validate timeoutMs if provided (FTR-037)\r\n    if (options.timeoutMs !== undefined) {\r\n      if (typeof options.timeoutMs !== 'number' || !Number.isInteger(options.timeoutMs)) {\r\n        throw new Error('timeoutMs must be an integer');\r\n      }\r\n      if (options.timeoutMs < 5000) {\r\n        throw new Error('timeoutMs must be at least 5000 (5 seconds)');\r\n      }\r\n      if (options.timeoutMs > 300000) {\r\n        throw new Error('timeoutMs must not exceed 300000 (5 minutes)');\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Validate image generation options.\r\n   * @internal\r\n   */\r\n  private validateImageOptions(options: ImageGenerationOptions): void {\r\n    if (!options.prompt || typeof options.prompt !== 'string') {\r\n      throw new Error('prompt is required and must be a string');\r\n    }\r\n\r\n    if (options.prompt.length === 0) {\r\n      throw new Error('prompt cannot be empty');\r\n    }\r\n\r\n    // GPT-Image supports up to 10 images\r\n    if (options.n !== undefined && (options.n < 1 || options.n > 10)) {\r\n      throw new Error('n must be between 1 and 10');\r\n    }\r\n\r\n    // Validate seed if provided\r\n    if (options.seed !== undefined && (options.seed < 1 || options.seed > 2147483647)) {\r\n      throw new Error('seed must be between 1 and 2147483647');\r\n    }\r\n\r\n    // Validate output_compression if provided\r\n    if (options.output_compression !== undefined && (options.output_compression < 0 || options.output_compression > 100)) {\r\n      throw new Error('output_compression must be between 0 and 100');\r\n    }\r\n\r\n    // Validate guidance_scale if provided\r\n    if (options.guidance_scale !== undefined && (options.guidance_scale < 1 || options.guidance_scale > 50)) {\r\n      throw new Error('guidance_scale must be between 1 and 50');\r\n    }\r\n\r\n    // Validate num_inference_steps if provided\r\n    if (options.num_inference_steps !== undefined && (options.num_inference_steps < 1 || options.num_inference_steps > 500)) {\r\n      throw new Error('num_inference_steps must be between 1 and 500');\r\n    }\r\n\r\n    // Validate reference_images array length (Nano Banana Pro supports up to 14)\r\n    if (options.reference_images !== undefined && options.reference_images.length > 14) {\r\n      throw new Error('reference_images cannot exceed 14 images');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Validate embedding options.\r\n   * @internal\r\n   */\r\n  private validateEmbeddingOptions(options: EmbeddingOptions): void {\r\n    if (!options.input) {\r\n      throw new Error('input is required');\r\n    }\r\n\r\n    if (typeof options.input === 'string') {\r\n      if (options.input.length === 0) {\r\n        throw new Error('input cannot be empty');\r\n      }\r\n    } else if (Array.isArray(options.input)) {\r\n      if (options.input.length === 0) {\r\n        throw new Error('input array cannot be empty');\r\n      }\r\n      for (const text of options.input) {\r\n        if (typeof text !== 'string' || text.length === 0) {\r\n          throw new Error('each input must be a non-empty string');\r\n        }\r\n      }\r\n    } else {\r\n      throw new Error('input must be a string or array of strings');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Validate transcription options.\r\n   * @internal\r\n   */\r\n  private validateTranscriptionOptions(options: TranscriptionOptions): void {\r\n    if (!options.file) {\r\n      throw new Error('file is required');\r\n    }\r\n\r\n    if (options.language && !/^[a-z]{2}$/.test(options.language)) {\r\n      throw new Error('language must be a valid ISO 639-1 code (2 lowercase letters)');\r\n    }\r\n\r\n    if (options.temperature !== undefined && (options.temperature < 0 || options.temperature > 1)) {\r\n      throw new Error('temperature must be between 0 and 1');\r\n    }\r\n\r\n    const validFormats = ['json', 'text', 'srt', 'vtt', 'verbose_json'];\r\n    if (options.response_format && !validFormats.includes(options.response_format)) {\r\n      throw new Error(`response_format must be one of: ${validFormats.join(', ')}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Validate speech options.\r\n   * @internal\r\n   */\r\n  private validateSpeechOptions(options: SpeechOptions): void {\r\n    if (!options.input || typeof options.input !== 'string') {\r\n      throw new Error('input is required and must be a string');\r\n    }\r\n\r\n    if (options.input.length === 0) {\r\n      throw new Error('input cannot be empty');\r\n    }\r\n\r\n    if (options.input.length > 4096) {\r\n      throw new Error('input cannot exceed 4096 characters');\r\n    }\r\n\r\n    const validVoices = ['alloy', 'echo', 'fable', 'onyx', 'nova', 'shimmer'];\r\n    if (!options.voice || !validVoices.includes(options.voice)) {\r\n      throw new Error(`voice is required and must be one of: ${validVoices.join(', ')}`);\r\n    }\r\n\r\n    if (options.speed !== undefined && (options.speed < 0.25 || options.speed > 4.0)) {\r\n      throw new Error('speed must be between 0.25 and 4.0');\r\n    }\r\n\r\n    const validFormats = ['mp3', 'opus', 'aac', 'flac', 'wav', 'pcm'];\r\n    if (options.response_format && !validFormats.includes(options.response_format)) {\r\n      throw new Error(`response_format must be one of: ${validFormats.join(', ')}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Extract error message from response body.\r\n   * @internal\r\n   */\r\n  private extractErrorMessage(body: Record<string, unknown>, status: number): string {\r\n    if ('error' in body && body['error'] && typeof body['error'] === 'object') {\r\n      const errorObj = body['error'] as Record<string, unknown>;\r\n      if ('message' in errorObj && typeof errorObj['message'] === 'string') {\r\n        return errorObj['message'];\r\n      }\r\n    }\r\n    return `AI request failed with status ${status}`;\r\n  }\r\n}\r\n\r\n/**\r\n * Stream chunk data from SSE.\r\n * @internal\r\n */\r\ninterface StreamChunkData {\r\n  choices?: Array<{\r\n    delta?: {\r\n      content?: string;\r\n    };\r\n    finish_reason?: string | null;\r\n  }>;\r\n}\r\n","/**\n * AuthHub Database Module\n *\n * Provides database query and transaction capabilities through AuthHub's\n * multi-tenant database routing.\n *\n * @module @authhub/sdk/db\n */\n\nimport type { QueryResult, TransactionContext } from '../types';\n\n/**\n * Request function type for making authenticated API calls.\n */\ntype RequestFn = <T>(options: {\n  method: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';\n  path: string;\n  body?: unknown;\n}) => Promise<T>;\n\n/**\n * Configuration for the database module.\n */\ninterface DBModuleConfig {\n  request: RequestFn;\n}\n\n/**\n * Transaction query for batch execution.\n */\ninterface TransactionQuery {\n  query: string;\n  parameters?: unknown[];\n}\n\n/**\n * API response wrapper format.\n */\ninterface ApiResponse<T> {\n  success: boolean;\n  data: T;\n  error?: string;\n  message?: string;\n}\n\n/**\n * Database module for queries and transactions.\n *\n * @example\n * ```typescript\n * // Simple query\n * const users = await client.db.query<User>(\n *   'SELECT * FROM users WHERE active = $1',\n *   [true]\n * );\n *\n * // Transaction\n * const result = await client.db.transaction(async (tx) => {\n *   await tx.query('INSERT INTO orders (user_id, total) VALUES ($1, $2)', [userId, 100]);\n *   await tx.query('UPDATE users SET order_count = order_count + 1 WHERE id = $1', [userId]);\n *   return { success: true };\n * });\n * ```\n */\nexport class DBModule {\n  private readonly config: DBModuleConfig;\n\n  /**\n   * Creates a new database module instance.\n   * @internal\n   */\n  constructor(config: DBModuleConfig) {\n    this.config = config;\n  }\n\n  /**\n   * Execute a parameterized SQL query.\n   *\n   * @param sql - SQL query with $1, $2, etc. placeholders\n   * @param params - Array of parameter values\n   * @returns Query result with rows and rowCount\n   * @throws {Error} If the query fails\n   *\n   * @example\n   * ```typescript\n   * interface User {\n   *   id: number;\n   *   name: string;\n   *   email: string;\n   * }\n   *\n   * const result = await client.db.query<User>(\n   *   'SELECT * FROM users WHERE email = $1',\n   *   ['user@example.com']\n   * );\n   *\n   * if (result.rowCount > 0) {\n   *   console.log(`Found user: ${result.rows[0].name}`);\n   * }\n   * ```\n   */\n  async query<T = Record<string, unknown>>(\n    sql: string,\n    params?: unknown[]\n  ): Promise<QueryResult<T>> {\n    if (!sql || typeof sql !== 'string') {\n      throw new Error('sql must be a non-empty string');\n    }\n\n    const response = await this.config.request<ApiResponse<QueryResult<T>>>({\n      method: 'POST',\n      path: '/api/v1/db/query',\n      body: {\n        query: sql,\n        parameters: params ?? [],\n      },\n    });\n\n    if (!response.success) {\n      throw new Error(response.error ?? response.message ?? 'Query failed');\n    }\n\n    return response.data;\n  }\n\n  /**\n   * Execute multiple queries within a transaction.\n   *\n   * All queries in the callback will be executed atomically - if any query\n   * fails, all changes will be rolled back. If all queries succeed, the\n   * transaction is committed.\n   *\n   * @param callback - Async function receiving a transaction context\n   * @returns The return value of the callback\n   * @throws {Error} If any query fails (transaction is rolled back)\n   *\n   * @example\n   * ```typescript\n   * const result = await client.db.transaction(async (tx) => {\n   *   // Deduct from sender\n   *   await tx.query(\n   *     'UPDATE accounts SET balance = balance - $1 WHERE id = $2',\n   *     [amount, senderId]\n   *   );\n   *\n   *   // Add to receiver\n   *   await tx.query(\n   *     'UPDATE accounts SET balance = balance + $1 WHERE id = $2',\n   *     [amount, receiverId]\n   *   );\n   *\n   *   // Log the transfer\n   *   await tx.query(\n   *     'INSERT INTO transfers (sender_id, receiver_id, amount) VALUES ($1, $2, $3)',\n   *     [senderId, receiverId, amount]\n   *   );\n   *\n   *   return { transferId: 'tx-123' };\n   * });\n   * ```\n   */\n  async transaction<T>(\n    callback: (tx: TransactionContext) => Promise<T>\n  ): Promise<T> {\n    // Collect queries from the callback\n    const queries: TransactionQuery[] = [];\n    let callbackResult: T | undefined;\n    let callbackError: Error | undefined;\n\n    // Create a mock transaction context that collects queries\n    const txContext: TransactionContext = {\n      query: async <R = Record<string, unknown>>(\n        sql: string,\n        params?: unknown[]\n      ): Promise<QueryResult<R>> => {\n        queries.push({ query: sql, parameters: params ?? [] });\n        // Return empty result during collection phase\n        return { rows: [] as R[], rowCount: 0 };\n      },\n    };\n\n    // Execute the callback to collect queries\n    try {\n      callbackResult = await callback(txContext);\n    } catch (err) {\n      callbackError = err instanceof Error ? err : new Error(String(err));\n    }\n\n    if (callbackError) {\n      throw callbackError;\n    }\n\n    if (queries.length === 0) {\n      // No queries to execute\n      return callbackResult as T;\n    }\n\n    // Execute all queries as a transaction on the server\n    const response = await this.config.request<ApiResponse<{\n      committed: boolean;\n      results: Array<QueryResult<unknown>>;\n      totalExecutionTime: number;\n    }>>({\n      method: 'POST',\n      path: '/api/v1/db/transaction',\n      body: {\n        queries,\n      },\n    });\n\n    if (!response.success || !response.data.committed) {\n      throw new Error(response.error ?? response.message ?? 'Transaction failed');\n    }\n\n    return callbackResult as T;\n  }\n}\n","/**\n * AuthHub Secrets Module\n *\n * Provides secure access to secrets assigned to your application.\n *\n * @module @authhub/sdk/secrets\n */\n\n/**\n * Request function type for making authenticated API calls.\n */\ntype RequestFn = <T>(options: {\n  method: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';\n  path: string;\n  body?: unknown;\n}) => Promise<T>;\n\n/**\n * Configuration for the secrets module.\n */\ninterface SecretsModuleConfig {\n  request: RequestFn;\n}\n\n/**\n * Response from the get secret endpoint.\n */\ninterface SecretResponse {\n  name: string;\n  value: string;\n}\n\n/**\n * Response from the list secrets endpoint.\n */\ninterface SecretsListResponse {\n  secrets: string[];\n}\n\n/**\n * Secrets module for accessing application secrets.\n *\n * @example\n * ```typescript\n * // Get a single secret\n * const apiKey = await client.secrets.get('STRIPE_API_KEY');\n *\n * // List available secrets\n * const names = await client.secrets.list();\n * console.log(`Available secrets: ${names.join(', ')}`);\n * ```\n */\nexport class SecretsModule {\n  private readonly config: SecretsModuleConfig;\n\n  /**\n   * Creates a new secrets module instance.\n   * @internal\n   */\n  constructor(config: SecretsModuleConfig) {\n    this.config = config;\n  }\n\n  /**\n   * Retrieve a secret value by name.\n   *\n   * @param name - Name of the secret to retrieve\n   * @returns The secret value as a string\n   * @throws {Error} If the secret is not found or not authorized\n   *\n   * @example\n   * ```typescript\n   * const stripeKey = await client.secrets.get('STRIPE_API_KEY');\n   * // Use stripeKey to initialize Stripe client\n   * ```\n   */\n  async get(name: string): Promise<string> {\n    if (!name || typeof name !== 'string') {\n      throw new Error('secret name must be a non-empty string');\n    }\n\n    // Validate name format (alphanumeric, underscores, hyphens only)\n    if (!/^[a-zA-Z0-9_-]+$/.test(name)) {\n      throw new Error('secret name contains invalid characters');\n    }\n\n    try {\n      const response = await this.config.request<SecretResponse>({\n        method: 'GET',\n        path: `/api/v1/secrets/${encodeURIComponent(name)}`,\n      });\n\n      return response.value;\n    } catch (error) {\n      // Sanitize error message to not expose secret name details\n      if (error instanceof Error) {\n        // Check for authorization errors\n        if (error.message.includes('403') || error.message.toLowerCase().includes('forbidden')) {\n          throw new Error(`Access denied to secret '${name}'`);\n        }\n        if (error.message.includes('404') || error.message.toLowerCase().includes('not found')) {\n          throw new Error(`Secret '${name}' not found`);\n        }\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * List all available secret names for this application.\n   *\n   * Note: This returns only the names, not the values. Use `get()` to\n   * retrieve individual secret values.\n   *\n   * @returns Array of secret names\n   * @throws {Error} If the request fails\n   *\n   * @example\n   * ```typescript\n   * const secretNames = await client.secrets.list();\n   * console.log('Available secrets:', secretNames);\n   * // ['STRIPE_API_KEY', 'DATABASE_PASSWORD', 'JWT_SECRET']\n   * ```\n   */\n  async list(): Promise<string[]> {\n    const response = await this.config.request<SecretsListResponse>({\n      method: 'GET',\n      path: '/api/v1/secrets',\n    });\n\n    return response.secrets;\n  }\n\n  /**\n   * Check if a secret exists without retrieving its value.\n   *\n   * @param name - Name of the secret to check\n   * @returns True if the secret exists and is accessible\n   *\n   * @example\n   * ```typescript\n   * if (await client.secrets.exists('STRIPE_API_KEY')) {\n   *   // Stripe integration is configured\n   * }\n   * ```\n   */\n  async exists(name: string): Promise<boolean> {\n    try {\n      const secrets = await this.list();\n      return secrets.includes(name);\n    } catch {\n      return false;\n    }\n  }\n}\n","/**\n * BreadcrumbTracker - Core breadcrumb tracking for Zero-Trust Debug Logging\n * @task TASK-561\n * @feature FTR-123\n */\n\nimport type { Breadcrumb, BreadcrumbConfig, BreadcrumbType, ElementDescriptor, BreadcrumbLevel } from './types.js';\n\n/** Default breadcrumb types to track */\nconst DEFAULT_BREADCRUMB_TYPES: BreadcrumbType[] = [\n  'click',\n  'navigation',\n  'xhr',\n  'fetch',\n  'console',\n  'dom',\n  'security',\n  'custom',\n];\n\n/**\n * BreadcrumbTracker maintains a list of user interactions\n * for debugging context when errors occur.\n */\nexport class BreadcrumbTracker {\n  private breadcrumbs: Breadcrumb[] = [];\n  private config: Required<BreadcrumbConfig>;\n  private initialized = false;\n  private cspViolationHandler: ((event: SecurityPolicyViolationEvent) => void) | null = null;\n\n  constructor(config: BreadcrumbConfig = {}) {\n    this.config = {\n      maxBreadcrumbs: config.maxBreadcrumbs ?? 50,\n      enabledTypes: config.enabledTypes ?? DEFAULT_BREADCRUMB_TYPES,\n      beforeBreadcrumb: config.beforeBreadcrumb ?? ((b) => b),\n    };\n  }\n\n  /**\n   * Add a breadcrumb to the list\n   * @param breadcrumb - Breadcrumb to add (timestamp optional)\n   */\n  add(breadcrumb: Omit<Breadcrumb, 'timestamp'> & { timestamp?: string }): void {\n    const bc: Breadcrumb = {\n      ...breadcrumb,\n      timestamp: breadcrumb.timestamp ?? new Date().toISOString(),\n    };\n\n    // Apply beforeBreadcrumb hook\n    const processed = this.config.beforeBreadcrumb(bc);\n    if (!processed) return;\n\n    // Check if type is enabled\n    if (!this.config.enabledTypes.includes(processed.type)) return;\n\n    this.breadcrumbs.push(processed);\n\n    // FIFO enforcement - remove oldest when exceeding max\n    while (this.breadcrumbs.length > this.config.maxBreadcrumbs) {\n      this.breadcrumbs.shift();\n    }\n  }\n\n  /**\n   * Get a copy of all breadcrumbs\n   * @returns Copy of breadcrumbs array\n   */\n  getBreadcrumbs(): Breadcrumb[] {\n    return [...this.breadcrumbs];\n  }\n\n  /**\n   * Clear all breadcrumbs\n   */\n  clear(): void {\n    this.breadcrumbs = [];\n  }\n\n  /**\n   * Get current configuration\n   */\n  getConfig(): Required<BreadcrumbConfig> {\n    return { ...this.config };\n  }\n\n  /**\n   * Check if tracker is initialized\n   */\n  isInitialized(): boolean {\n    return this.initialized;\n  }\n\n  /**\n   * Initialize click, navigation, and HTTP tracking with event listeners\n   * Safe to call multiple times - will only initialize once\n   * @task TASK-563\n   */\n  init(): void {\n    if (this.initialized || typeof window === 'undefined' || typeof document === 'undefined') return;\n    this.initialized = true;\n\n    // Click tracking\n    document.addEventListener('click', this.handleClick.bind(this), true);\n\n    // Navigation tracking (TASK-563)\n    window.addEventListener('popstate', this.handleNavigation.bind(this));\n    this.wrapHistoryMethod('pushState');\n    this.wrapHistoryMethod('replaceState');\n\n    // HTTP tracking (TASK-563)\n    this.wrapFetch();\n    this.wrapXHR();\n\n    // Console tracking (TASK-564)\n    this.wrapConsole();\n\n    // CSP violation tracking\n    this.cspViolationHandler = this.handleCSPViolation.bind(this);\n    document.addEventListener('securitypolicyviolation', this.cspViolationHandler);\n  }\n\n  /**\n   * Clean up event listeners\n   */\n  destroy(): void {\n    if (!this.initialized || typeof window === 'undefined' || typeof document === 'undefined') return;\n    document.removeEventListener('click', this.handleClick.bind(this), true);\n    if (this.cspViolationHandler) {\n      document.removeEventListener('securitypolicyviolation', this.cspViolationHandler);\n      this.cspViolationHandler = null;\n    }\n    this.initialized = false;\n  }\n\n  /**\n   * Handle click events and create breadcrumbs\n   */\n  private handleClick(event: MouseEvent): void {\n    const target = event.target as HTMLElement;\n    if (!target) return;\n\n    const descriptor = this.getElementDescriptor(target);\n\n    this.add({\n      type: 'click',\n      category: 'ui',\n      message: `Clicked ${descriptor.tag}${descriptor.id ? '#' + descriptor.id : ''}`,\n      data: { element: descriptor },\n    });\n  }\n\n  /**\n   * Get safe element descriptor without PII\n   * Only captures structural/identifying attributes\n   */\n  private getElementDescriptor(el: HTMLElement): ElementDescriptor {\n    const desc: ElementDescriptor = {\n      tag: el.tagName.toLowerCase(),\n    };\n    if (el.id) desc.id = el.id;\n    if (el.className && typeof el.className === 'string') {\n      const classes = el.className.split(' ').filter(Boolean);\n      if (classes.length > 0) desc.classes = classes;\n    }\n    const role = el.getAttribute('role');\n    if (role) desc.role = role;\n    const ariaLabel = el.getAttribute('aria-label');\n    if (ariaLabel) desc['aria-label'] = ariaLabel;\n    const testId = el.getAttribute('data-testid');\n    if (testId) desc['data-testid'] = testId;\n    return desc;\n  }\n\n  /**\n   * Handle CSP violation events and create breadcrumbs\n   */\n  private handleCSPViolation(event: SecurityPolicyViolationEvent): void {\n    this.add({\n      type: 'security',\n      category: 'csp',\n      message: `CSP violation: ${event.violatedDirective} blocked ${event.blockedURI || 'inline'}`,\n      data: {\n        violatedDirective: event.violatedDirective,\n        blockedURI: event.blockedURI,\n        sourceFile: event.sourceFile,\n        lineNumber: event.lineNumber,\n        columnNumber: event.columnNumber,\n        originalPolicy: event.originalPolicy,\n      },\n      level: 'error',\n    });\n  }\n\n  /**\n   * Handle popstate navigation events\n   * @task TASK-563\n   */\n  private handleNavigation(): void {\n    this.add({\n      type: 'navigation',\n      category: 'navigation',\n      message: `Navigated to ${this.sanitizeUrl(window.location.href)}`,\n      data: { path: this.sanitizeUrl(window.location.href) },\n    });\n  }\n\n  /**\n   * Sanitize URL to remove query params and hash for privacy\n   * Only returns pathname to avoid capturing PII in URLs\n   * @task TASK-563\n   */\n  private sanitizeUrl(url: string): string {\n    try {\n      let base = 'http://localhost';\n      if (typeof window !== 'undefined' && window.location && window.location.origin) {\n        base = window.location.origin;\n      }\n      const parsed = new URL(url, base);\n      return parsed.pathname;\n    } catch {\n      const noQuery = url.split('?')[0] ?? url;\n      return noQuery.split('#')[0] ?? noQuery;\n    }\n  }\n\n  /**\n   * Wrap history pushState/replaceState to track SPA navigation\n   * @task TASK-563\n   */\n  private wrapHistoryMethod(method: 'pushState' | 'replaceState'): void {\n    const original = history[method].bind(history);\n    const tracker = this;\n    history[method] = function(...args: Parameters<typeof history.pushState>) {\n      const result = original(...args);\n      tracker.add({\n        type: 'navigation',\n        category: 'navigation',\n        message: `Navigated to ${tracker.sanitizeUrl(window.location.pathname)}`,\n        data: { method, path: tracker.sanitizeUrl(window.location.pathname) },\n      });\n      return result;\n    };\n  }\n\n  /**\n   * Wrap fetch API to track HTTP requests\n   * Only captures method, path, and status - never request bodies\n   * @task TASK-563\n   */\n  private wrapFetch(): void {\n    const originalFetch = window.fetch.bind(window);\n    const tracker = this;\n    window.fetch = async function(input: RequestInfo | URL, init?: RequestInit) {\n      const url = typeof input === 'string' ? input : (input as Request).url;\n      const method = init?.method || 'GET';\n\n      try {\n        const response = await originalFetch(input, init);\n        tracker.add({\n          type: 'fetch',\n          category: 'http',\n          message: `${method} ${tracker.sanitizeUrl(url)} ${response.status}`,\n          data: { method, path: tracker.sanitizeUrl(url), status: response.status },\n        });\n        return response;\n      } catch (error) {\n        tracker.add({\n          type: 'fetch',\n          category: 'http',\n          message: `${method} ${tracker.sanitizeUrl(url)} failed`,\n          data: { method, path: tracker.sanitizeUrl(url), error: 'network_error' },\n          level: 'error',\n        });\n        throw error;\n      }\n    };\n  }\n\n  /**\n   * Wrap XMLHttpRequest to track XHR requests\n   * Only captures method, path, and status - never request bodies\n   * @task TASK-563\n   */\n  private wrapXHR(): void {\n    const tracker = this;\n    const OriginalXHR = window.XMLHttpRequest;\n\n    window.XMLHttpRequest = function() {\n      const xhr = new OriginalXHR();\n      let method = 'GET';\n      let url = '';\n\n      const originalOpen = xhr.open.bind(xhr);\n      xhr.open = function(reqMethod: string, reqUrl: string | URL, async_?: boolean, username?: string | null, password?: string | null) {\n        method = reqMethod;\n        url = typeof reqUrl === 'string' ? reqUrl : reqUrl.toString();\n        return originalOpen(reqMethod, reqUrl, async_ ?? true, username ?? null, password ?? null);\n      };\n\n      xhr.addEventListener('loadend', () => {\n        tracker.add({\n          type: 'xhr',\n          category: 'http',\n          message: `${method} ${tracker.sanitizeUrl(url)} ${xhr.status}`,\n          data: { method, path: tracker.sanitizeUrl(url), status: xhr.status },\n          level: xhr.status >= 400 ? 'error' : 'info',\n        });\n      });\n\n      return xhr;\n    } as unknown as typeof XMLHttpRequest;\n  }\n\n  /**\n   * Wrap console methods to track debug/info/warn/error\n   * @task TASK-564\n   */\n  private wrapConsole(): void {\n    const levels: Array<{ method: 'debug' | 'info' | 'warn' | 'error'; level: BreadcrumbLevel }> = [\n      { method: 'debug', level: 'debug' },\n      { method: 'info', level: 'info' },\n      { method: 'warn', level: 'warning' },\n      { method: 'error', level: 'error' },\n    ];\n\n    for (const { method, level } of levels) {\n      const original = console[method].bind(console);\n      const tracker = this;\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      (console as any)[method] = function(...args: unknown[]) {\n        tracker.addConsoleBreadcrumb(level, args);\n        original(...args);\n      };\n    }\n  }\n\n  /**\n   * Add a console breadcrumb from logged message\n   * @task TASK-564\n   */\n  private addConsoleBreadcrumb(level: BreadcrumbLevel, args: unknown[]): void {\n    const message = this.formatConsoleMessage(args);\n\n    this.add({\n      type: 'console',\n      category: 'console',\n      message,\n      level,\n    });\n  }\n\n  /**\n   * Format console arguments into a safe message string\n   * Truncates at 500 chars, sanitizes PII, and replaces objects\n   * @task TASK-564\n   */\n  private formatConsoleMessage(args: unknown[]): string {\n    const parts = args.map(arg => {\n      if (typeof arg === 'string') {\n        return this.sanitizeConsoleString(arg);\n      }\n      if (arg instanceof Error) {\n        return `Error: ${arg.message}`;\n      }\n      if (typeof arg === 'object' && arg !== null) {\n        return '[Object]';\n      }\n      return String(arg);\n    });\n\n    const message = parts.join(' ');\n    return message.length > 500 ? message.slice(0, 497) + '...' : message;\n  }\n\n  /**\n   * Sanitize console string to redact PII patterns\n   * @task TASK-564\n   */\n  private sanitizeConsoleString(str: string): string {\n    // Redact emails\n    return str.replace(\n      /\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b/g,\n      '[REDACTED]'\n    );\n  }\n}\n","/**\n * Semantic DOM Capture Strategy\n * Captures a privacy-safe representation of the DOM for debugging\n * @task TASK-567, TASK-568\n * @feature FTR-119\n */\n\nimport type {\n  CaptureStrategy,\n  CaptureContext,\n  SemanticDOMCapture,\n  ElementNode,\n} from './types.js';\n\n/** Maximum depth for recursive element capture */\nconst MAX_DEPTH = 10;\n\n/** Tags to exclude from capture */\nconst EXCLUDED_TAGS = new Set([\n  'script', 'style', 'noscript', 'svg', 'template', 'iframe', 'link', 'meta',\n]);\n\n/** Safe attributes to capture (whitelist) */\nconst SAFE_ATTRIBUTES = new Set([\n  'id', 'class', 'role',\n  'aria-label', 'aria-describedby', 'aria-expanded', 'aria-selected',\n  'aria-hidden', 'aria-haspopup', 'aria-controls',\n  'type', 'name', 'placeholder',\n  'disabled', 'readonly', 'required',\n  'data-testid', 'data-component',\n]);\n\n/** PII patterns for filtering sensitive data */\nconst PII_PATTERNS = [\n  /\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b/,  // Email\n  /\\b\\d{3}[-.]?\\d{3}[-.]?\\d{4}\\b/,  // Phone\n  /\\b(?:\\d{4}[-\\s]?){3}\\d{4}\\b/,   // Credit card\n];\n\n/**\n * Strategy that captures a semantic representation of the DOM\n * without any text content or input values (PII safe)\n */\nexport class SemanticDOMStrategy implements CaptureStrategy<SemanticDOMCapture> {\n  readonly name = 'semantic_dom';\n  readonly maxSize = 5120; // 5KB\n\n  async capture(_context?: CaptureContext): Promise<SemanticDOMCapture> {\n    if (typeof document === 'undefined') {\n      throw new Error('SemanticDOMStrategy requires a DOM environment');\n    }\n\n    const rootElement = this.captureElement(document.body);\n\n    const result: SemanticDOMCapture = {\n      rootElement: rootElement || { tag: 'body' },\n      scrollPosition: {\n        x: typeof window !== 'undefined' ? window.scrollX : 0,\n        y: typeof window !== 'undefined' ? window.scrollY : 0,\n      },\n      viewportSize: {\n        width: typeof window !== 'undefined' ? window.innerWidth : 0,\n        height: typeof window !== 'undefined' ? window.innerHeight : 0,\n      },\n      capturedAt: new Date().toISOString(),\n    };\n    const activeEl = this.getActiveElementSelector();\n    if (activeEl) result.activeElement = activeEl;\n    return result;\n  }\n\n  private getActiveElementSelector(): string | undefined {\n    const active = document.activeElement;\n    if (!active || active === document.body) return undefined;\n    return this.generateSelector(active as HTMLElement);\n  }\n\n  private generateSelector(el: HTMLElement): string {\n    if (el.id) return `#${el.id}`;\n\n    const tag = el.tagName.toLowerCase();\n    const classes = el.className && typeof el.className === 'string'\n      ? el.className.split(' ').filter(Boolean).slice(0, 2).join('.')\n      : '';\n\n    return classes ? `${tag}.${classes}` : tag;\n  }\n\n  private captureElement(el: HTMLElement | null, depth = 0): ElementNode | null {\n    if (!el) return null;\n\n    const tag = el.tagName.toLowerCase();\n\n    // Exclude certain tags\n    if (EXCLUDED_TAGS.has(tag)) {\n      return null;\n    }\n\n    // Stop at max depth\n    if (depth > MAX_DEPTH) {\n      return { tag, children: [] };\n    }\n\n    const node: ElementNode = { tag };\n\n    // Capture ID\n    if (el.id) node.id = el.id;\n\n    // Capture classes\n    if (el.className && typeof el.className === 'string') {\n      const classes = el.className.split(' ').filter(Boolean);\n      if (classes.length) node.classList = classes;\n    }\n\n    // Capture safe attributes only\n    const attributes: Record<string, string> = {};\n    for (const attr of Array.from(el.attributes)) {\n      if (SAFE_ATTRIBUTES.has(attr.name) || attr.name.startsWith('aria-') || attr.name.startsWith('data-')) {\n        // Skip class and id as they're already captured\n        if (attr.name !== 'class' && attr.name !== 'id') {\n          // Skip if looks like PII\n          if (this.isPotentialPII(attr.value)) continue;\n\n          // Truncate long values (>100 chars)\n          const truncatedValue = attr.value.length > 100 ? attr.value.slice(0, 97) + '...' : attr.value;\n          attributes[attr.name] = truncatedValue;\n        }\n      }\n    }\n    if (Object.keys(attributes).length) {\n      node.attributes = attributes;\n    }\n\n    // Extract role\n    const role = el.getAttribute('role');\n    if (role) node.role = role;\n\n    // Extract label (aria-label or associated label)\n    const label = this.extractLabel(el);\n    if (label) node.label = label;\n\n    // Recurse into children with depth limit\n    if (depth < MAX_DEPTH && el.children.length > 0) {\n      const children: ElementNode[] = [];\n      for (const child of Array.from(el.children)) {\n        const captured = this.captureElement(child as HTMLElement, depth + 1);\n        if (captured) children.push(captured);\n      }\n      if (children.length) node.children = children;\n    }\n\n    return node;\n  }\n\n  private isPotentialPII(value: string): boolean {\n    return PII_PATTERNS.some(pattern => pattern.test(value));\n  }\n\n  private extractLabel(el: HTMLElement): string | undefined {\n    // Try aria-label first\n    const ariaLabel = el.getAttribute('aria-label');\n    if (ariaLabel) return ariaLabel;\n\n    // Try aria-labelledby\n    const labelledBy = el.getAttribute('aria-labelledby');\n    if (labelledBy) {\n      const labelEl = document.getElementById(labelledBy);\n      if (labelEl) return labelEl.textContent?.trim() || undefined;\n    }\n\n    // Try associated label for form elements\n    if (el.id) {\n      const label = document.querySelector(`label[for=\"${el.id}\"]`);\n      if (label) return label.textContent?.trim() || undefined;\n    }\n\n    return undefined;\n  }\n}\n\nexport { MAX_DEPTH, EXCLUDED_TAGS, SAFE_ATTRIBUTES, PII_PATTERNS };\n","/**\n * Synthetic Screenshot Capture Strategy\n * Uses dom-to-image for DOM-to-canvas rendering\n *\n * @task TASK-572\n * @feature FTR-120\n */\n\nimport type {\n  CaptureStrategy,\n  CaptureContext,\n  SyntheticScreenshotCapture,\n} from './types.js';\n\n/** Selectors for elements that should be masked during capture */\nexport const MASK_SELECTORS = [\n  'input[type=\"password\"]',\n  'input[type=\"email\"]',\n  'input[type=\"tel\"]',\n  'input[type=\"text\"]',\n  'input[type=\"number\"]',\n  'input:not([type])', // Default inputs without type\n  'textarea',\n  '[data-sensitive]',\n  '[data-pii]',\n];\n\n/** Mask value - 8 bullet characters */\nexport const MASK_VALUE = '';\n\nexport class SyntheticScreenshotStrategy\n  implements CaptureStrategy<SyntheticScreenshotCapture>\n{\n  readonly name = 'synthetic_screenshot';\n  readonly maxSize = 15360; // 15KB\n\n  // Storage for masked element restoration\n  private maskedElements: Array<{\n    element: HTMLInputElement | HTMLTextAreaElement;\n    originalValue: string;\n    selector: string;\n  }> = [];\n\n  async capture(context?: CaptureContext): Promise<SyntheticScreenshotCapture> {\n    // Check for DOM environment\n    if (typeof document === 'undefined') {\n      throw new Error('SyntheticScreenshotStrategy requires a DOM environment');\n    }\n\n    const maskedSelectors = this.maskInputs();\n\n    try {\n      const scrollHeight = document.body.scrollHeight\n        || document.documentElement?.scrollHeight\n        || window.innerHeight;\n\n      const { default: domToImage } = await import('dom-to-image-more');\n      const dataUrl = await domToImage.toPng(document.body, {\n        quality: 0.6,\n        bgcolor: '#ffffff',\n        width: Math.min(window.innerWidth, 1920),\n        height: Math.min(scrollHeight, 4000),\n      });\n\n      // Strip data URL prefix\n      const imageData = dataUrl.replace(/^data:image\\/png;base64,/, '');\n\n      // Calculate error element position if provided\n      let errorLocation: { x: number; y: number; selector: string } | undefined;\n      if (context?.element) {\n        const rect = context.element.getBoundingClientRect();\n        errorLocation = {\n          x: rect.left,\n          y: rect.top,\n          selector: this.generateSelector(context.element),\n        };\n      }\n\n      // Use scrollHeight from body, documentElement, or fallback to innerHeight\n      const height = document.body.scrollHeight\n        || document.documentElement?.scrollHeight\n        || window.innerHeight;\n\n      const result: SyntheticScreenshotCapture = {\n        imageData,\n        dimensions: {\n          width: window.innerWidth,\n          height,\n        },\n        maskedElements: maskedSelectors,\n        capturedAt: new Date().toISOString(),\n      };\n      if (errorLocation) result.errorLocation = errorLocation;\n      return result;\n    } finally {\n      this.restoreInputs();\n    }\n  }\n\n  private generateSelector(el: HTMLElement): string {\n    if (el.id) return `#${el.id}`;\n    const classes = el.className\n      ? el.className.split(' ').filter(Boolean).slice(0, 2).join('.')\n      : '';\n    return classes\n      ? `${el.tagName.toLowerCase()}.${classes}`\n      : el.tagName.toLowerCase();\n  }\n\n  private maskInputs(): string[] {\n    const selectors: string[] = [];\n    const selectorQuery = MASK_SELECTORS.join(', ');\n    const inputs = document.querySelectorAll(selectorQuery);\n\n    inputs.forEach((input) => {\n      const el = input as HTMLInputElement | HTMLTextAreaElement;\n      const originalValue = el.value;\n      const selector = this.generateSelector(el);\n\n      if (originalValue) {\n        this.maskedElements.push({\n          element: el,\n          originalValue,\n          selector,\n        });\n        selectors.push(selector);\n\n        // Store original value in dataset before masking\n        (el.dataset as Record<string, string>)['__originalValue'] = originalValue;\n\n        // Mask with 8 bullet characters\n        el.value = MASK_VALUE;\n      }\n    });\n\n    return selectors;\n  }\n\n  private restoreInputs(): void {\n    this.maskedElements.forEach(({ element, originalValue }) => {\n      element.value = originalValue;\n      // Clean up dataset backup\n      delete (element.dataset as Record<string, string>)['__originalValue'];\n    });\n    this.maskedElements = [];\n  }\n}\n","/**\n * AOM Tree Capture Strategy for Zero-Trust Debug Logging\n * Captures accessibility tree structure, focus order, and landmarks\n *\n * @task TASK-575\n * @feature FTR-121\n */\n\nimport type {\n  CaptureStrategy,\n  CaptureContext,\n  AOMTreeCapture,\n  AccessibilityNode,\n  AccessibilityState,\n  LandmarkInfo,\n} from './types.js';\n\nexport class AOMTreeStrategy implements CaptureStrategy<AOMTreeCapture> {\n  readonly name = 'aom_tree';\n  readonly maxSize = 8192; // 8KB\n  static readonly MAX_DEPTH = 8;\n\n  /**\n   * Implicit role mapping for semantic HTML elements\n   * Based on WAI-ARIA 1.2 specification\n   */\n  static readonly IMPLICIT_ROLES: Record<string, string | undefined> = {\n    a: 'link',\n    article: 'article',\n    aside: 'complementary',\n    button: 'button',\n    footer: 'contentinfo',\n    form: 'form',\n    h1: 'heading',\n    h2: 'heading',\n    h3: 'heading',\n    h4: 'heading',\n    h5: 'heading',\n    h6: 'heading',\n    header: 'banner',\n    img: 'img',\n    input: undefined, // Depends on type\n    li: 'listitem',\n    main: 'main',\n    nav: 'navigation',\n    ol: 'list',\n    option: 'option',\n    progress: 'progressbar',\n    section: 'region',\n    select: 'combobox',\n    table: 'table',\n    textarea: 'textbox',\n    ul: 'list',\n  };\n\n  /**\n   * Input type to role mapping for input elements\n   */\n  static readonly INPUT_TYPE_ROLES: Record<string, string> = {\n    button: 'button',\n    checkbox: 'checkbox',\n    email: 'textbox',\n    number: 'spinbutton',\n    radio: 'radio',\n    range: 'slider',\n    search: 'searchbox',\n    submit: 'button',\n    tel: 'textbox',\n    text: 'textbox',\n  };\n\n  async capture(_context?: CaptureContext): Promise<AOMTreeCapture> {\n    if (typeof document === 'undefined') {\n      throw new Error('AOMTreeStrategy requires a DOM environment');\n    }\n\n    const result: AOMTreeCapture = {\n      rootNode: this.captureAccessibilityNode(document.body),\n      focusOrder: this.getFocusOrder(),\n      landmarks: this.getLandmarks(),\n      capturedAt: new Date().toISOString(),\n    };\n    const focused = this.getFocusedElementSelector();\n    if (focused) result.focusedElement = focused;\n    return result;\n  }\n\n  private getFocusedElementSelector(): string | undefined {\n    const focused = document.activeElement;\n    if (!focused || focused === document.body) return undefined;\n    return this.generateSelector(focused as HTMLElement);\n  }\n\n  private generateSelector(el: HTMLElement): string {\n    if (el.id) return `#${el.id}`;\n    const tag = el.tagName.toLowerCase();\n    const classes =\n      el.className && typeof el.className === 'string'\n        ? el.className\n            .split(' ')\n            .filter(Boolean)\n            .slice(0, 2)\n            .join('.')\n        : '';\n    return classes ? `${tag}.${classes}` : tag;\n  }\n\n  private getFocusOrder(): string[] {\n    const focusable = document.querySelectorAll<HTMLElement>(\n      'a[href], button, input, select, textarea, [tabindex]:not([tabindex=\"-1\"])'\n    );\n\n    return Array.from(focusable)\n      .slice(0, 50)\n      .map((el) => this.generateSelector(el));\n  }\n\n  private getLandmarks(): LandmarkInfo[] {\n    const landmarks: LandmarkInfo[] = [];\n\n    // Semantic HTML elements as landmarks\n    const semanticLandmarks = document.querySelectorAll(\n      'header, nav, main, aside, footer'\n    );\n    for (let i = 0; i < semanticLandmarks.length && landmarks.length < 20; i++) {\n      const el = semanticLandmarks[i] as HTMLElement;\n      const info: LandmarkInfo = {\n        role: this.getImplicitRole(el),\n        selector: this.generateSelector(el),\n      };\n      const lbl = el.getAttribute('aria-label');\n      if (lbl) info.label = lbl;\n      landmarks.push(info);\n    }\n\n    // Explicit role landmarks\n    const landmarkRoles = [\n      'banner',\n      'navigation',\n      'main',\n      'complementary',\n      'contentinfo',\n      'search',\n      'form',\n      'region',\n    ];\n\n    for (const role of landmarkRoles) {\n      if (landmarks.length >= 20) break;\n      const elements = document.querySelectorAll(`[role=\"${role}\"]`);\n      for (let i = 0; i < elements.length && landmarks.length < 20; i++) {\n        const el = elements[i] as HTMLElement;\n        const info: LandmarkInfo = {\n          role,\n          selector: this.generateSelector(el),\n        };\n        const lbl = el.getAttribute('aria-label');\n        if (lbl) info.label = lbl;\n        landmarks.push(info);\n      }\n    }\n\n    return landmarks.slice(0, 20);\n  }\n\n  /**\n   * Get the role for an element, preferring explicit over implicit\n   */\n  private getRole(el: HTMLElement): string {\n    // Explicit role always takes precedence\n    const explicitRole = el.getAttribute('role');\n    if (explicitRole) return explicitRole;\n\n    const tag = el.tagName.toLowerCase();\n\n    // Handle input elements specially based on type\n    if (tag === 'input') {\n      const type = el.getAttribute('type') || 'text';\n      return AOMTreeStrategy.INPUT_TYPE_ROLES[type] || 'textbox';\n    }\n\n    // Use implicit role mapping\n    const implicitRole = AOMTreeStrategy.IMPLICIT_ROLES[tag];\n    return implicitRole ?? 'generic';\n  }\n\n  /**\n   * Get the implicit role for semantic landmark elements\n   * Used specifically for landmark extraction\n   */\n  private getImplicitRole(el: HTMLElement): string {\n    const tag = el.tagName.toLowerCase();\n    const implicitRoles: Record<string, string> = {\n      header: 'banner',\n      nav: 'navigation',\n      main: 'main',\n      aside: 'complementary',\n      footer: 'contentinfo',\n    };\n    return implicitRoles[tag] || 'generic';\n  }\n\n  /**\n   * Get the accessible name for an element following ARIA name computation\n   * Priority: aria-label > aria-labelledby > associated label > alt (for images)\n   */\n  private getAccessibleName(el: HTMLElement): string | undefined {\n    // 1. aria-label takes highest priority\n    const ariaLabel = el.getAttribute('aria-label');\n    if (ariaLabel) return ariaLabel;\n\n    // 2. aria-labelledby references another element\n    const labelledBy = el.getAttribute('aria-labelledby');\n    if (labelledBy) {\n      const labelElement = document.getElementById(labelledBy);\n      if (labelElement?.textContent) {\n        return labelElement.textContent;\n      }\n    }\n\n    // 3. Associated label for form controls\n    const id = el.getAttribute('id') || el.id;\n    if (id) {\n      const associatedLabel = document.querySelector(`label[for=\"${id}\"]`);\n      if (associatedLabel?.textContent) {\n        return associatedLabel.textContent;\n      }\n    }\n\n    // 4. alt text for images\n    const tag = el.tagName.toLowerCase();\n    if (tag === 'img') {\n      const alt = el.getAttribute('alt');\n      if (alt) return alt;\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Get the accessible description for an element from aria-describedby\n   */\n  private getAccessibleDescription(el: HTMLElement): string | undefined {\n    const describedBy = el.getAttribute('aria-describedby');\n    if (describedBy) {\n      const descElement = document.getElementById(describedBy);\n      if (descElement?.textContent) {\n        return descElement.textContent;\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * Capture the accessibility state of an element from ARIA attributes\n   * and native HTML properties.\n   *\n   * Supports: disabled, expanded, selected, checked (including mixed),\n   * pressed, hidden, and invalid states.\n   */\n  private getState(el: HTMLElement): AccessibilityState | undefined {\n    const state: AccessibilityState = {};\n    let hasState = false;\n\n    // disabled: aria-disabled or native disabled property\n    const ariaDisabled = el.getAttribute('aria-disabled');\n    if (ariaDisabled === 'true' || (el as HTMLButtonElement).disabled === true) {\n      state.disabled = true;\n      hasState = true;\n    }\n\n    // expanded: aria-expanded\n    const ariaExpanded = el.getAttribute('aria-expanded');\n    if (ariaExpanded === 'true') {\n      state.expanded = true;\n      hasState = true;\n    } else if (ariaExpanded === 'false') {\n      state.expanded = false;\n      hasState = true;\n    }\n\n    // selected: aria-selected\n    const ariaSelected = el.getAttribute('aria-selected');\n    if (ariaSelected === 'true') {\n      state.selected = true;\n      hasState = true;\n    } else if (ariaSelected === 'false') {\n      state.selected = false;\n      hasState = true;\n    }\n\n    // checked: aria-checked (supports \"true\", \"false\", \"mixed\")\n    // For native checkboxes, also check the checked property\n    const ariaChecked = el.getAttribute('aria-checked');\n    if (ariaChecked === 'true') {\n      state.checked = true;\n      hasState = true;\n    } else if (ariaChecked === 'false') {\n      state.checked = false;\n      hasState = true;\n    } else if (ariaChecked === 'mixed') {\n      // Mixed state represented as undefined checked but we need a signal.\n      // The AccessibilityState interface uses boolean, so we encode mixed\n      // by omitting checked but noting it in state. However, since the\n      // interface only supports boolean, we'll use undefined to indicate mixed\n      // and rely on the 'mixed' string from aria-checked.\n      // For now, we store it as false to indicate \"not fully checked\"\n      // but mark it in a way tests can verify. Since the type is boolean | undefined,\n      // we represent mixed as undefined (not set) - consumers should check\n      // aria-checked=\"mixed\" directly if they need tri-state.\n      // Actually, let's just not set checked for mixed - the absence combined\n      // with aria-checked=\"mixed\" on the element is the signal.\n      hasState = true;\n    } else if (\n      el.tagName.toLowerCase() === 'input' &&\n      el.getAttribute('type') === 'checkbox' &&\n      (el as HTMLInputElement).checked === true\n    ) {\n      state.checked = true;\n      hasState = true;\n    }\n\n    // pressed: aria-pressed\n    const ariaPressed = el.getAttribute('aria-pressed');\n    if (ariaPressed === 'true') {\n      state.pressed = true;\n      hasState = true;\n    } else if (ariaPressed === 'false') {\n      state.pressed = false;\n      hasState = true;\n    }\n\n    // hidden: aria-hidden\n    const ariaHidden = el.getAttribute('aria-hidden');\n    if (ariaHidden === 'true') {\n      state.hidden = true;\n      hasState = true;\n    }\n\n    // invalid: aria-invalid\n    const ariaInvalid = el.getAttribute('aria-invalid');\n    if (ariaInvalid === 'true') {\n      state.invalid = true;\n      hasState = true;\n    }\n\n    return hasState ? state : undefined;\n  }\n\n  /**\n   * Recursively capture an accessibility node and its children.\n   *\n   * - Excludes elements with aria-hidden=\"true\" from the tree\n   * - Enforces a depth limit of MAX_DEPTH (8 levels) to prevent\n   *   excessive recursion in deeply nested DOMs\n   * - Captures role, name, description, state, and children\n   *\n   * @param el - The HTML element to capture\n   * @param depth - Current recursion depth (0-based)\n   * @returns The accessibility node representation\n   */\n  private captureAccessibilityNode(\n    el: HTMLElement | null,\n    depth: number = 0\n  ): AccessibilityNode {\n    if (!el) return { role: 'generic' };\n\n    const node: AccessibilityNode = {\n      role: this.getRole(el),\n    };\n    const name = this.getAccessibleName(el);\n    if (name) node.name = name;\n    const description = this.getAccessibleDescription(el);\n    if (description) node.description = description;\n\n    // Capture accessibility state\n    const state = this.getState(el);\n    if (state) {\n      node.state = state;\n    }\n\n    // Recurse into children if within depth limit\n    if (depth < AOMTreeStrategy.MAX_DEPTH && el.children && el.children.length > 0) {\n      const children: AccessibilityNode[] = [];\n\n      for (let i = 0; i < el.children.length; i++) {\n        const child = el.children[i] as HTMLElement;\n\n        // Skip elements with aria-hidden=\"true\"\n        if (child.getAttribute && child.getAttribute('aria-hidden') === 'true') {\n          continue;\n        }\n\n        children.push(this.captureAccessibilityNode(child, depth + 1));\n      }\n\n      if (children.length > 0) {\n        node.children = children;\n      }\n    }\n\n    return node;\n  }\n}\n","/**\n * AST Capture Strategy - Stack Parsing\n *\n * Parses error stack traces from Chrome/Edge and Firefox formats\n * to extract structured call stack frame information.\n *\n * @task TASK-579\n * @feature FTR-122\n */\n\nimport type {\n  CaptureStrategy,\n  CaptureContext,\n  ASTCapture,\n  CallStackFrame,\n} from './types.js';\n\nexport class ASTStrategy implements CaptureStrategy<ASTCapture> {\n  readonly name = 'ast';\n  readonly maxSize = 10240;\n\n  // Chrome/Edge: \"    at functionName (file:line:col)\" or \"    at file:line:col\"\n  private static readonly CHROME_REGEX =\n    /^\\s*at\\s+(?:(.+?)\\s+\\()?(.+?):(\\d+):(\\d+)\\)?$/;\n\n  // Firefox: \"functionName@file:line:col\"\n  private static readonly FIREFOX_REGEX =\n    /^(.*)@(.+?):(\\d+):(\\d+)$/;\n\n  async capture(context?: CaptureContext): Promise<ASTCapture> {\n    const error = context?.error || new Error('Capture point');\n    const stack = error.stack || '';\n    const callStack = this.parseStack(stack);\n    const errorLocation = this.getErrorLocation(callStack);\n\n    return {\n      errorLocation,\n      contextNodes: [],\n      callStack,\n      capturedAt: new Date().toISOString(),\n    };\n  }\n\n  private parseStack(stack: string): CallStackFrame[] {\n    const frames: CallStackFrame[] = [];\n    const lines = stack.split('\\n');\n\n    for (const line of lines) {\n      if (frames.length >= 20) break;\n      const frame = this.parseStackLine(line);\n      if (frame) frames.push(frame);\n    }\n\n    return frames;\n  }\n\n  private parseStackLine(line: string): CallStackFrame | null {\n    let match = line.match(ASTStrategy.CHROME_REGEX);\n    if (match) {\n      return {\n        functionName: this.sanitizeFunctionName(match[1] || ''),\n        fileName: this.sanitizeFileName(match[2] || ''),\n        lineNumber: parseInt(match[3] || '0', 10),\n        columnNumber: parseInt(match[4] || '0', 10),\n      };\n    }\n\n    match = line.match(ASTStrategy.FIREFOX_REGEX);\n    if (match) {\n      return {\n        functionName: this.sanitizeFunctionName(match[1] || ''),\n        fileName: this.sanitizeFileName(match[2] || ''),\n        lineNumber: parseInt(match[3] || '0', 10),\n        columnNumber: parseInt(match[4] || '0', 10),\n      };\n    }\n\n    return null;\n  }\n\n  private sanitizeFileName(fileName: string): string {\n    let sanitized = fileName;\n\n    // Extract pathname from URLs (http://, https://, file://)\n    try {\n      const url = new URL(sanitized);\n      sanitized = url.pathname;\n    } catch {\n      // Not a URL, use as-is\n    }\n\n    // Remove query strings and hash fragments\n    const queryIndex = sanitized.indexOf('?');\n    if (queryIndex !== -1) {\n      sanitized = sanitized.substring(0, queryIndex);\n    }\n    const hashIndex = sanitized.indexOf('#');\n    if (hashIndex !== -1) {\n      sanitized = sanitized.substring(0, hashIndex);\n    }\n\n    // Truncate to 200 characters\n    if (sanitized.length > 200) {\n      sanitized = sanitized.substring(0, 200);\n    }\n\n    return sanitized;\n  }\n\n  private sanitizeFunctionName(name: string): string {\n    // Keep only alphanumeric, underscore, dot, angle brackets, and square brackets\n    let sanitized = name.replace(/[^a-zA-Z0-9_.<>\\[\\]]/g, '');\n\n    // Return '<anonymous>' if empty after sanitization\n    if (sanitized.length === 0) {\n      return '<anonymous>';\n    }\n\n    // Truncate to 100 characters\n    if (sanitized.length > 100) {\n      sanitized = sanitized.substring(0, 100);\n    }\n\n    return sanitized;\n  }\n\n  private getErrorLocation(\n    callStack: CallStackFrame[],\n  ): ASTCapture['errorLocation'] {\n    const firstFrame = callStack[0];\n    const loc: ASTCapture['errorLocation'] = {\n      file: firstFrame?.fileName || 'unknown',\n      line: firstFrame?.lineNumber || 0,\n      column: firstFrame?.columnNumber || 0,\n    };\n    if (firstFrame?.functionName) loc.functionName = firstFrame.functionName;\n    return loc;\n  }\n}\n","/**\n * DebugModule - Zero-Trust Debug Logging SDK\n * @task TASK-583\n * @feature FTR-124\n */\n\nimport { BreadcrumbTracker } from './breadcrumbs.js';\nimport {\n  SemanticDOMStrategy,\n  SyntheticScreenshotStrategy,\n  AOMTreeStrategy,\n  ASTStrategy,\n  type CaptureStrategy,\n} from './strategies/index.js';\nimport type {\n  DebugModuleConfig,\n  CaptureStrategyName,\n  UserContext,\n  CaptureOptions,\n  CaptureResult,\n  CaptureEvent,\n  BreadcrumbType,\n  BreadcrumbLevel,\n} from './types.js';\n\n/**\n * Mapping from public hyphenated strategy names to internal underscore names\n * used by strategy classes.\n */\nconst STRATEGY_NAME_MAP: Record<CaptureStrategyName, string> = {\n  'semantic-dom': 'semantic_dom',\n  'synthetic-screenshot': 'synthetic_screenshot',\n  'aom-tree': 'aom_tree',\n  'ast-capture': 'ast',\n};\n\nexport class DebugModule {\n  private config: DebugModuleConfig;\n  private breadcrumbTracker: BreadcrumbTracker;\n  private strategies: Map<string, CaptureStrategy>;\n  private userContext: UserContext | null = null;\n  private tags: Record<string, string> = {};\n  private sessionId: string;\n  private initialized = false;\n  private originalOnError: OnErrorEventHandler | null = null;\n  private unhandledRejectionHandler: ((event: PromiseRejectionEvent) => void) | null = null;\n  private cspViolationHandler: ((event: SecurityPolicyViolationEvent) => void) | null = null;\n\n  constructor(config: DebugModuleConfig) {\n    this.config = {\n      enabled: config.enabled ?? true,\n      sampleRate: config.sampleRate ?? 1.0,\n      environment: config.environment ?? 'production',\n      release: config.release ?? '',\n      maxBreadcrumbs: config.maxBreadcrumbs ?? 50,\n      appId: config.appId,\n      apiUrl: config.apiUrl,\n    };\n    if (config.strategies) this.config.strategies = config.strategies;\n    if (config.beforeCapture) this.config.beforeCapture = config.beforeCapture;\n    if (config.request) this.config.request = config.request;\n\n    this.breadcrumbTracker = new BreadcrumbTracker({\n      maxBreadcrumbs: this.config.maxBreadcrumbs ?? 50,\n    });\n\n    this.strategies = new Map<string, CaptureStrategy>([\n      ['semantic_dom', new SemanticDOMStrategy()],\n      ['synthetic_screenshot', new SyntheticScreenshotStrategy()],\n      ['aom_tree', new AOMTreeStrategy()],\n      ['ast', new ASTStrategy()],\n    ]);\n\n    this.sessionId = this.getOrCreateSessionId();\n  }\n\n  /**\n   * Generate or retrieve a persistent session ID.\n   * Uses sessionStorage in browser environments for persistence\n   * across page navigations within the same session.\n   * Falls back to random generation in non-browser environments.\n   */\n  private getOrCreateSessionId(): string {\n    if (typeof globalThis.sessionStorage === 'undefined') {\n      return typeof crypto !== 'undefined' && crypto.randomUUID\n        ? crypto.randomUUID()\n        : Math.random().toString(36).slice(2) + Date.now().toString(36);\n    }\n    const key = '__authhub_debug_session_id';\n    let id = sessionStorage.getItem(key);\n    if (!id) {\n      id = crypto.randomUUID();\n      sessionStorage.setItem(key, id);\n    }\n    return id;\n  }\n\n  /**\n   * Resolve a public CaptureStrategyName to an internal strategy key.\n   * Returns the underscore-format key used in the strategies Map.\n   */\n  resolveStrategyName(name: CaptureStrategyName): string {\n    return STRATEGY_NAME_MAP[name];\n  }\n\n  /**\n   * Get a capture strategy by its internal underscore-format name.\n   */\n  getStrategy(name: string): CaptureStrategy | undefined {\n    return this.strategies.get(name);\n  }\n\n  /**\n   * Get the current session ID.\n   */\n  getSessionId(): string {\n    return this.sessionId;\n  }\n\n  /**\n   * Check if the module has been initialized.\n   */\n  isInitialized(): boolean {\n    return this.initialized;\n  }\n\n  /**\n   * Check if the module is enabled.\n   */\n  isEnabled(): boolean {\n    return this.config.enabled ?? true;\n  }\n\n  /**\n   * Get the current configuration (read-only copy).\n   */\n  getConfig(): DebugModuleConfig {\n    return { ...this.config };\n  }\n\n  /**\n   * Get the breadcrumb tracker instance.\n   */\n  getBreadcrumbTracker(): BreadcrumbTracker {\n    return this.breadcrumbTracker;\n  }\n\n  /**\n   * Set user context for associating captures with an anonymous user.\n   */\n  setUserContext(user: UserContext | null): void {\n    this.userContext = user;\n  }\n\n  /**\n   * Get the current user context.\n   */\n  getUserContext(): UserContext | null {\n    return this.userContext;\n  }\n\n  /**\n   * Set a tag key-value pair for all future captures.\n   */\n  setTag(key: string, value: string): void {\n    this.tags[key] = value;\n  }\n\n  /**\n   * Get all currently set tags.\n   */\n  getTags(): Record<string, string> {\n    return { ...this.tags };\n  }\n\n  /**\n   * Initialize auto-instrumentation\n   * Registers global error handler and unhandled rejection handler.\n   * Safe to call multiple times -- only initializes once.\n   * @task TASK-584\n   */\n  init(): void {\n    if (this.initialized) return;\n    if (typeof window === 'undefined') return;\n\n    this.initialized = true;\n    this.breadcrumbTracker.init();\n\n    // Global error handler\n    this.originalOnError = window.onerror;\n    window.onerror = (message, source, lineno, colno, error) => {\n      if (this.isEnabled()) {\n        this.captureError(error || new Error(String(message)));\n      }\n      if (this.originalOnError) {\n        return this.originalOnError.call(window, message, source, lineno, colno, error);\n      }\n      return false;\n    };\n\n    // Unhandled promise rejection handler\n    this.unhandledRejectionHandler = (event: PromiseRejectionEvent) => {\n      if (this.isEnabled()) {\n        const error = event.reason instanceof Error\n          ? event.reason\n          : new Error(String(event.reason));\n        this.captureError(error, { level: 'error' });\n      }\n    };\n    window.addEventListener('unhandledrejection', this.unhandledRejectionHandler);\n\n    // CSP violation handler - captures as errors\n    this.cspViolationHandler = (event: SecurityPolicyViolationEvent) => {\n      if (this.isEnabled()) {\n        const error = new Error(\n          `CSP violation: ${event.violatedDirective} blocked ${event.blockedURI || 'inline'}`\n        );\n        error.name = 'SecurityPolicyViolation';\n        this.captureError(error, {\n          level: 'error',\n          tags: {\n            'csp.directive': event.violatedDirective,\n            'csp.blockedURI': event.blockedURI || '',\n            'csp.sourceFile': event.sourceFile || '',\n          },\n        });\n      }\n    };\n    document.addEventListener('securitypolicyviolation', this.cspViolationHandler);\n  }\n\n  /**\n   * Clean up auto-instrumentation and stop tracking.\n   * @task TASK-584\n   */\n  destroy(): void {\n    if (!this.initialized) return;\n\n    this.breadcrumbTracker.destroy();\n\n    // Restore original error handler\n    if (typeof window !== 'undefined') {\n      window.onerror = this.originalOnError;\n      this.originalOnError = null;\n\n      if (this.unhandledRejectionHandler) {\n        window.removeEventListener('unhandledrejection', this.unhandledRejectionHandler);\n        this.unhandledRejectionHandler = null;\n      }\n    }\n\n    if (typeof document !== 'undefined' && this.cspViolationHandler) {\n      document.removeEventListener('securitypolicyviolation', this.cspViolationHandler);\n      this.cspViolationHandler = null;\n    }\n\n    this.initialized = false;\n  }\n\n  /**\n   * Capture an error with the configured strategy\n   * @task TASK-585\n   */\n  async captureError(\n    error: Error,\n    options: CaptureOptions = {}\n  ): Promise<CaptureResult | null> {\n    if (!this.isEnabled()) return null;\n    if (Math.random() > (this.config.sampleRate ?? 1)) return null;\n\n    try {\n      const requestedStrategy = options.strategies?.[0] || this.config.strategies?.[0] || 'semantic-dom' as CaptureStrategyName;\n      const strategyName = this.resolveStrategyName(requestedStrategy) || 'semantic_dom';\n\n      const strategy = this.strategies.get(strategyName);\n      if (!strategy) return null;\n\n      const captureData = await strategy.capture({ error });\n\n      const errorInfo: CaptureEvent['error'] = {\n        name: error.name,\n        message: error.message,\n      };\n      if (error.stack) errorInfo.stack = error.stack;\n\n      const context: CaptureEvent['context'] = {\n        tags: { ...this.tags, ...options.tags },\n      };\n      if (this.userContext) context.user = this.userContext;\n\n      let event: CaptureEvent = {\n        error: errorInfo,\n        capture: {\n          strategies: [requestedStrategy],\n          timestamp: new Date().toISOString(),\n          data: captureData,\n        },\n        context,\n        breadcrumbs: this.breadcrumbTracker.getBreadcrumbs(),\n      };\n\n      if (this.config.beforeCapture) {\n        const modified = this.config.beforeCapture(event);\n        if (!modified) return null;\n        event = modified;\n      }\n\n      if (this.config.request) {\n        const response = await this.config.request(\n          `${this.config.apiUrl}/api/v1/debug/capture`,\n          {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify({\n              error: {\n                type: event.error.name,\n                message: event.error.message,\n                stack: event.error.stack,\n              },\n              severity: options.level === 'debug' ? 'info' : (options.level ?? 'error'),\n              capture: { strategy: strategyName, data: event.capture.data },\n              context: typeof window !== 'undefined' ? {\n                url: window.location.pathname,\n                userAgent: navigator.userAgent,\n                viewport: { width: window.innerWidth, height: window.innerHeight },\n              } : undefined,\n              breadcrumbs: event.breadcrumbs?.map((bc) => ({\n                ...bc,\n                timestamp: new Date(bc.timestamp).getTime(),\n              })),\n              metadata: {\n                environment: this.config.environment,\n                release: this.config.release,\n                sessionId: this.sessionId,\n              },\n            }),\n          }\n        );\n\n        if (response.ok) {\n          return await response.json() as CaptureResult;\n        }\n\n        if (response.status === 429) {\n          console.warn('[AuthHub Debug] Rate limited');\n        } else if (response.status === 403) {\n          console.warn('[AuthHub Debug] API key lacks debug scope');\n        } else {\n          const body = await response.text().catch(() => '');\n          console.warn(`[AuthHub Debug] Capture failed (${response.status}): ${body}`);\n        }\n      }\n\n      return null;\n    } catch (err) {\n      console.error('[AuthHub Debug] Capture error:', err);\n      return null;\n    }\n  }\n\n  /**\n   * Capture a non-error message\n   * @task TASK-587\n   */\n  async captureMessage(message: string, options: CaptureOptions = {}): Promise<CaptureResult | null> {\n    const error = new Error(message);\n    error.name = 'Message';\n    return this.captureError(error, { level: 'info', ...options });\n  }\n\n  /**\n   * Add a custom breadcrumb\n   * @task TASK-587\n   */\n  addBreadcrumb(breadcrumb: {\n    type?: BreadcrumbType;\n    category: string;\n    message: string;\n    data?: Record<string, unknown>;\n    level?: BreadcrumbLevel;\n  }): void {\n    const bc: Parameters<BreadcrumbTracker['add']>[0] = {\n      type: breadcrumb.type ?? 'custom',\n      category: breadcrumb.category,\n      message: breadcrumb.message,\n    };\n    if (breadcrumb.data) bc.data = breadcrumb.data;\n    if (breadcrumb.level) bc.level = breadcrumb.level;\n    this.breadcrumbTracker.add(bc);\n  }\n\n  /**\n   * Set user context (anonymous ID only)\n   * @task TASK-587\n   */\n  setUser(user: UserContext | null): void {\n    if (user && !user.id) {\n      console.warn('[AuthHub Debug] UserContext requires id field');\n      return;\n    }\n    this.userContext = user;\n  }\n\n  /**\n   * Set multiple tags\n   * @task TASK-587\n   */\n  setTags(tags: Record<string, string>): void {\n    this.tags = { ...this.tags, ...tags };\n  }\n\n  /**\n   * Clear all breadcrumbs\n   * @task TASK-587\n   */\n  clearBreadcrumbs(): void {\n    this.breadcrumbTracker.clear();\n  }\n\n  /**\n   * Get current user context\n   * @task TASK-587\n   */\n  getUser(): UserContext | null {\n    return this.userContext;\n  }\n}\n","/**\n * AuthHub SDK Version\n *\n * @module @authhub/sdk/version\n */\n\n/**\n * Current SDK version.\n * Update this when publishing new releases.\n */\nexport const SDK_VERSION = '1.0.0';\n\n/**\n * SDK client identifier for tracking.\n */\nexport const SDK_CLIENT = 'typescript';\n","/**\r\n * AuthHub Client\r\n *\r\n * Core client implementation with HTTP utilities and request handling.\r\n *\r\n * @module @authhub/sdk/client\r\n */\r\n\r\nimport type {\r\n  AuthHubClientConfig,\r\n  DebugClientConfig,\r\n  ApiErrorResponse,\r\n} from './types';\r\nimport type { AuthModuleConfig, AuthUser } from './auth/types';\r\nimport { AIModule } from './ai';\r\nimport { DBModule } from './db';\r\nimport { SecretsModule } from './secrets';\r\nimport { DebugModule } from './debug/index';\r\nimport { SDK_VERSION, SDK_CLIENT } from './version';\r\n\r\n/**\r\n * Internal config type with required core fields.\r\n * Auth config is optional and handled separately.\r\n * @internal\r\n */\r\ninterface InternalClientConfig {\r\n  baseUrl: string;\r\n  apiKey: string;\r\n  timeout: number;\r\n  retries: number;\r\n  auth: AuthModuleConfig | undefined;\r\n  debug: DebugClientConfig | undefined;\r\n}\r\n\r\n/**\r\n * HTTP method types supported by the client.\r\n */\r\ntype HttpMethod = 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';\r\n\r\n/**\r\n * Error that should not be retried.\r\n * @internal\r\n */\r\nclass NonRetryableError extends Error {\r\n  constructor(message: string) {\r\n    super(message);\r\n    this.name = 'NonRetryableError';\r\n  }\r\n}\r\n\r\n/**\r\n * Options for making HTTP requests.\r\n */\r\ninterface RequestOptions {\r\n  method: HttpMethod;\r\n  path: string;\r\n  body?: unknown;\r\n  params?: Record<string, string | number | boolean | undefined>;\r\n  timeout?: number;\r\n  /** Additional headers to merge with defaults (overrides on conflict). */\r\n  headers?: Record<string, string>;\r\n}\r\n\r\n/**\r\n * AuthHub client for accessing all AuthHub services.\r\n *\r\n * @example\r\n * ```typescript\r\n * const client = new AuthHubClient({\r\n *   baseUrl: 'https://authhub.example.com',\r\n *   apiKey: 'ak_your_api_key',\r\n * });\r\n *\r\n * // Make authenticated requests\r\n * const response = await client.ai.chat({\r\n *   model: 'gpt-4',\r\n *   messages: [{ role: 'user', content: 'Hello!' }],\r\n * });\r\n * ```\r\n */\r\nexport class AuthHubClient {\r\n  private readonly config: InternalClientConfig;\r\n\r\n  /**\r\n   * AI module for chat completions.\r\n   */\r\n  public readonly ai: AIModule;\r\n\r\n  /**\r\n   * Database module for queries and transactions.\r\n   */\r\n  public readonly db: DBModule;\r\n\r\n  /**\r\n   * Secrets module for accessing application secrets.\r\n   */\r\n  public readonly secrets: SecretsModule;\r\n\r\n  /**\r\n   * Lazily-initialized debug module instance.\r\n   * @internal\r\n   */\r\n  private _debug: DebugModule | null = null;\r\n\r\n  /**\r\n   * Debug module for zero-trust debug logging and error capture.\r\n   *\r\n   * Lazily initialized on first access. Configure via the `debug` option\r\n   * in `AuthHubClientConfig`.\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const client = new AuthHubClient({\r\n   *   baseUrl: 'https://authhub.example.com',\r\n   *   apiKey: 'ak_your_api_key',\r\n   *   debug: {\r\n   *     environment: 'production',\r\n   *     release: '1.2.0',\r\n   *     sampleRate: 0.5,\r\n   *   },\r\n   * });\r\n   *\r\n   * // Auto-instrument global error handlers\r\n   * client.initDebug();\r\n   *\r\n   * // Manual error capture\r\n   * try {\r\n   *   await riskyOperation();\r\n   * } catch (error) {\r\n   *   await client.debug.captureError(error);\r\n   * }\r\n   * ```\r\n   */\r\n  get debug(): DebugModule {\r\n    if (!this._debug) {\r\n      const debugConfig = this.config.debug ?? {};\r\n      const debugInit: import('./debug/types').DebugModuleConfig = {\r\n        appId: this.config.apiKey,\r\n        apiUrl: this.config.baseUrl,\r\n        request: (url: string, init?: RequestInit) => fetch(url, {\r\n          ...init,\r\n          headers: {\r\n            ...init?.headers,\r\n            'X-API-Key': this.config.apiKey,\r\n            'X-SDK-Version': SDK_VERSION,\r\n            'X-SDK-Client': SDK_CLIENT,\r\n          },\r\n        }),\r\n        environment: debugConfig.environment ?? 'production',\r\n        release: debugConfig.release ?? '',\r\n      };\r\n      if (debugConfig.enabled !== undefined) debugInit.enabled = debugConfig.enabled;\r\n      if (debugConfig.sampleRate !== undefined) debugInit.sampleRate = debugConfig.sampleRate;\r\n      if (debugConfig.maxBreadcrumbs !== undefined) debugInit.maxBreadcrumbs = debugConfig.maxBreadcrumbs;\r\n      if (debugConfig.strategies) debugInit.strategies = debugConfig.strategies;\r\n      this._debug = new DebugModule(debugInit);\r\n    }\r\n    return this._debug;\r\n  }\r\n\r\n  /**\r\n   * Initialize debug auto-instrumentation.\r\n   *\r\n   * Registers global error handlers (`window.onerror`, `unhandledrejection`)\r\n   * and starts breadcrumb tracking. Safe to call multiple times.\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const client = new AuthHubClient({ ... });\r\n   * client.initDebug(); // Start capturing errors automatically\r\n   * ```\r\n   */\r\n  initDebug(): void {\r\n    this.debug.init();\r\n  }\r\n\r\n  /**\r\n   * Creates a new AuthHub client.\r\n   *\r\n   * @param config - Client configuration options\r\n   * @throws {Error} If baseUrl is missing\r\n   * @throws {Error} If apiKey is missing\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const client = new AuthHubClient({\r\n   *   baseUrl: 'https://authhub.example.com',\r\n   *   apiKey: 'ak_your_api_key',\r\n   *   timeout: 60000, // 60 seconds\r\n   *   retries: 5,\r\n   * });\r\n   * ```\r\n   */\r\n  constructor(config: AuthHubClientConfig) {\r\n    if (!config.baseUrl) {\r\n      throw new Error('AuthHubClient: baseUrl is required');\r\n    }\r\n    if (!config.apiKey) {\r\n      throw new Error('AuthHubClient: apiKey is required');\r\n    }\r\n\r\n    this.config = {\r\n      baseUrl: config.baseUrl.replace(/\\/$/, ''), // Remove trailing slash\r\n      apiKey: config.apiKey,\r\n      timeout: config.timeout ?? 30000,\r\n      retries: config.retries ?? 3,\r\n      auth: config.auth,\r\n      debug: config.debug,\r\n    };\r\n\r\n    // Initialize modules\r\n    this.ai = new AIModule({\r\n      request: this.request.bind(this),\r\n      baseUrl: this.config.baseUrl,\r\n      apiKey: this.config.apiKey,\r\n      timeout: this.config.timeout,\r\n    });\r\n\r\n    this.db = new DBModule({\r\n      request: this.request.bind(this),\r\n    });\r\n\r\n    this.secrets = new SecretsModule({\r\n      request: this.request.bind(this),\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get the base URL of the AuthHub API.\r\n   */\r\n  get baseUrl(): string {\r\n    return this.config.baseUrl;\r\n  }\r\n\r\n  /**\r\n   * Get the configured timeout in milliseconds.\r\n   */\r\n  get timeout(): number {\r\n    return this.config.timeout;\r\n  }\r\n\r\n  /**\r\n   * Get the configured retry count.\r\n   */\r\n  get retries(): number {\r\n    return this.config.retries;\r\n  }\r\n\r\n  /**\r\n   * Build the full URL for an API request.\r\n   *\r\n   * @param path - API endpoint path\r\n   * @param params - Optional query parameters\r\n   * @returns Full URL with query string\r\n   */\r\n  protected buildUrl(\r\n    path: string,\r\n    params?: Record<string, string | number | boolean | undefined>\r\n  ): string {\r\n    const url = new URL(path, this.config.baseUrl);\r\n\r\n    if (params) {\r\n      for (const [key, value] of Object.entries(params)) {\r\n        if (value !== undefined) {\r\n          url.searchParams.set(key, String(value));\r\n        }\r\n      }\r\n    }\r\n\r\n    return url.toString();\r\n  }\r\n\r\n  /**\r\n   * Get default headers for API requests.\r\n   *\r\n   * Includes tracking headers for request correlation and SDK version tracking.\r\n   *\r\n   * @returns Headers object with authentication, content type, and tracking info\r\n   */\r\n  protected getHeaders(): Record<string, string> {\r\n    return {\r\n      'X-API-Key': this.config.apiKey,\r\n      'Content-Type': 'application/json',\r\n      'Accept': 'application/json',\r\n      // Tracking headers for observability\r\n      'X-Request-ID': this.generateRequestId(),\r\n      'X-SDK-Version': SDK_VERSION,\r\n      'X-SDK-Client': SDK_CLIENT,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Generate a unique request ID for correlation.\r\n   *\r\n   * Uses crypto.randomUUID() if available, otherwise falls back to timestamp-based ID.\r\n   *\r\n   * @returns Unique request ID\r\n   * @internal\r\n   */\r\n  private generateRequestId(): string {\r\n    if (typeof crypto !== 'undefined' && crypto.randomUUID) {\r\n      return crypto.randomUUID();\r\n    }\r\n    // Fallback for environments without crypto.randomUUID\r\n    return `${Date.now()}-${Math.random().toString(36).substring(2, 15)}`;\r\n  }\r\n\r\n  /**\r\n   * Make an authenticated HTTP request to the AuthHub API.\r\n   *\r\n   * @param options - Request options\r\n   * @returns Parsed JSON response\r\n   * @throws {Error} If the request fails or returns an error response\r\n   *\r\n   * @internal\r\n   */\r\n  protected async request<T>(options: RequestOptions): Promise<T> {\r\n    const { method, path, body, params, timeout, headers: extraHeaders } = options;\r\n    const url = this.buildUrl(path, params);\r\n    const headers = { ...this.getHeaders(), ...extraHeaders };\r\n\r\n    const controller = new AbortController();\r\n    const timeoutId = setTimeout(\r\n      () => controller.abort(),\r\n      timeout ?? this.config.timeout\r\n    );\r\n\r\n    let lastError: Error | null = null;\r\n    let attempts = 0;\r\n\r\n    while (attempts < this.config.retries) {\r\n      attempts++;\r\n\r\n      try {\r\n        const response = await fetch(url, {\r\n          method,\r\n          headers,\r\n          body: body !== undefined ? JSON.stringify(body) : null,\r\n          signal: controller.signal,\r\n        });\r\n\r\n        clearTimeout(timeoutId);\r\n\r\n        if (!response.ok) {\r\n          const errorBody = await response.json().catch(() => ({})) as ApiErrorResponse | Record<string, unknown>;\r\n\r\n          // Extract error message from response\r\n          const extractErrorMessage = (): string => {\r\n            if ('error' in errorBody && errorBody.error && typeof errorBody.error === 'object') {\r\n              const errorObj = errorBody.error as Record<string, unknown>;\r\n              if ('message' in errorObj && typeof errorObj['message'] === 'string') {\r\n                return errorObj['message'];\r\n              }\r\n            }\r\n            return `Request failed with status ${response.status}`;\r\n          };\r\n\r\n          const errorMessage = extractErrorMessage();\r\n\r\n          // Don't retry client errors (4xx) except 429 (rate limit)\r\n          if (response.status >= 400 && response.status < 500 && response.status !== 429) {\r\n            throw new NonRetryableError(errorMessage);\r\n          }\r\n\r\n          // Retry on server errors (5xx) and rate limits (429)\r\n          lastError = new Error(errorMessage);\r\n\r\n          // Exponential backoff: 100ms, 200ms, 400ms, etc.\r\n          if (attempts < this.config.retries) {\r\n            await this.delay(100 * Math.pow(2, attempts - 1));\r\n          }\r\n          continue;\r\n        }\r\n\r\n        // Handle empty responses (204 No Content)\r\n        if (response.status === 204) {\r\n          return {} as T;\r\n        }\r\n\r\n        return (await response.json()) as T;\r\n      } catch (error) {\r\n        clearTimeout(timeoutId);\r\n\r\n        if (error instanceof Error) {\r\n          // Don't retry non-retryable errors (4xx client errors)\r\n          if (error instanceof NonRetryableError) {\r\n            throw new Error(error.message);\r\n          }\r\n\r\n          if (error.name === 'AbortError') {\r\n            throw new Error(`Request timed out after ${timeout ?? this.config.timeout}ms`);\r\n          }\r\n\r\n          lastError = error;\r\n\r\n          // Exponential backoff for network errors\r\n          if (attempts < this.config.retries) {\r\n            await this.delay(100 * Math.pow(2, attempts - 1));\r\n          }\r\n        } else {\r\n          throw error;\r\n        }\r\n      }\r\n    }\r\n\r\n    throw lastError ?? new Error('Request failed after retries');\r\n  }\r\n\r\n  /**\r\n   * Delay execution for the specified milliseconds.\r\n   *\r\n   * @param ms - Milliseconds to delay\r\n   */\r\n  private delay(ms: number): Promise<void> {\r\n    return new Promise((resolve) => setTimeout(resolve, ms));\r\n  }\r\n\r\n  /**\r\n   * Make a GET request.\r\n   *\r\n   * @param path - API endpoint path\r\n   * @param params - Optional query parameters\r\n   * @returns Parsed JSON response\r\n   *\r\n   * @internal\r\n   */\r\n  protected get<T>(\r\n    path: string,\r\n    params?: Record<string, string | number | boolean | undefined>\r\n  ): Promise<T> {\r\n    return this.request<T>({ method: 'GET', path, ...(params && { params }) });\r\n  }\r\n\r\n  /**\r\n   * Make a POST request.\r\n   *\r\n   * @param path - API endpoint path\r\n   * @param body - Request body\r\n   * @returns Parsed JSON response\r\n   *\r\n   * @internal\r\n   */\r\n  protected post<T>(path: string, body?: unknown): Promise<T> {\r\n    return this.request<T>({ method: 'POST', path, body });\r\n  }\r\n\r\n  /**\r\n   * Make a PUT request.\r\n   *\r\n   * @param path - API endpoint path\r\n   * @param body - Request body\r\n   * @returns Parsed JSON response\r\n   *\r\n   * @internal\r\n   */\r\n  protected put<T>(path: string, body?: unknown): Promise<T> {\r\n    return this.request<T>({ method: 'PUT', path, body });\r\n  }\r\n\r\n  /**\r\n   * Make a DELETE request.\r\n   *\r\n   * @param path - API endpoint path\r\n   * @returns Parsed JSON response\r\n   *\r\n   * @internal\r\n   */\r\n  protected delete<T>(path: string): Promise<T> {\r\n    return this.request<T>({ method: 'DELETE', path });\r\n  }\r\n\r\n  /**\r\n   * Verify a Bearer token and return the authenticated user.\r\n   *\r\n   * Use this server-side to validate tokens from incoming requests.\r\n   * Calls the AuthHub `/api/v1/auth/me` endpoint with the provided token.\r\n   *\r\n   * @param token - The Bearer access token to verify\r\n   * @returns The authenticated user, or null if the token is invalid/expired\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * // Next.js API route\r\n   * const token = request.headers.get('Authorization')?.slice(7);\r\n   * if (!token) return Response.json({ error: 'Unauthorized' }, { status: 401 });\r\n   *\r\n   * const user = await client.verifyToken(token);\r\n   * if (!user) return Response.json({ error: 'Unauthorized' }, { status: 401 });\r\n   *\r\n   * // user.id, user.email, user.name are available\r\n   * ```\r\n   */\r\n  async verifyToken(token: string): Promise<AuthUser | null> {\r\n    try {\r\n      const response = await this.request<{ data: { user: AuthUser } }>({\r\n        method: 'GET',\r\n        path: '/api/v1/auth/me',\r\n        headers: {\r\n          'Authorization': `Bearer ${token}`,\r\n        },\r\n      });\r\n      return response.data?.user ?? null;\r\n    } catch {\r\n      return null;\r\n    }\r\n  }\r\n}\r\n","/**\n * AuthHub SDK Errors\n *\n * Custom error classes for different failure scenarios.\n *\n * @module @authhub/sdk/errors\n */\n\n/**\n * Base error class for all AuthHub SDK errors.\n *\n * @example\n * ```typescript\n * try {\n *   await client.ai.chat({ model: 'gpt-4', messages: [] });\n * } catch (error) {\n *   if (error instanceof AuthHubError) {\n *     console.error(`Code: ${error.code}, Status: ${error.statusCode}`);\n *   }\n * }\n * ```\n */\nexport class AuthHubError extends Error {\n  /**\n   * Error code for programmatic handling.\n   */\n  readonly code: string;\n\n  /**\n   * HTTP status code (if applicable).\n   */\n  readonly statusCode: number | undefined;\n\n  /**\n   * Additional error details.\n   */\n  readonly details: Record<string, unknown> | undefined;\n\n  constructor(\n    message: string,\n    code: string,\n    statusCode?: number,\n    details?: Record<string, unknown>\n  ) {\n    super(message);\n    this.name = 'AuthHubError';\n    this.code = code;\n    this.statusCode = statusCode;\n    this.details = details;\n\n    // Maintains proper stack trace for where our error was thrown\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, AuthHubError);\n    }\n  }\n\n  /**\n   * Get a user-friendly error message with troubleshooting hints.\n   */\n  get hint(): string {\n    switch (this.code) {\n      case 'AUTH_ERROR':\n        return 'Check your API key is correct and not expired.';\n      case 'RATE_LIMIT':\n        return 'You are being rate limited. Wait and retry.';\n      case 'VALIDATION_ERROR':\n        return 'Check your request parameters.';\n      case 'NETWORK_ERROR':\n        return 'Check your network connection and AuthHub URL.';\n      default:\n        return 'An unexpected error occurred.';\n    }\n  }\n}\n\n/**\n * Authentication error (401 Unauthorized).\n *\n * Thrown when the API key is invalid, expired, or missing.\n */\nexport class AuthError extends AuthHubError {\n  constructor(message: string = 'Authentication failed', details?: Record<string, unknown>) {\n    super(message, 'AUTH_ERROR', 401, details);\n    this.name = 'AuthError';\n  }\n}\n\n/**\n * Rate limit error (429 Too Many Requests).\n *\n * Thrown when the API rate limit has been exceeded.\n */\nexport class RateLimitError extends AuthHubError {\n  /**\n   * Seconds to wait before retrying (from Retry-After header).\n   */\n  readonly retryAfter: number | undefined;\n\n  constructor(\n    message: string = 'Rate limit exceeded',\n    retryAfter?: number,\n    details?: Record<string, unknown>\n  ) {\n    super(message, 'RATE_LIMIT', 429, details);\n    this.name = 'RateLimitError';\n    this.retryAfter = retryAfter;\n  }\n}\n\n/**\n * Validation error (400 Bad Request).\n *\n * Thrown when the request parameters are invalid.\n */\nexport class ValidationError extends AuthHubError {\n  /**\n   * Fields that failed validation.\n   */\n  readonly fields: Record<string, string> | undefined;\n\n  constructor(\n    message: string = 'Validation failed',\n    fields?: Record<string, string>,\n    details?: Record<string, unknown>\n  ) {\n    super(message, 'VALIDATION_ERROR', 400, { ...details, fields });\n    this.name = 'ValidationError';\n    this.fields = fields;\n  }\n}\n\n/**\n * Network error for connection failures.\n *\n * Thrown when the request could not be completed due to network issues.\n */\nexport class NetworkError extends AuthHubError {\n  /**\n   * Whether this error is likely transient and worth retrying.\n   */\n  readonly isTransient: boolean;\n\n  constructor(\n    message: string = 'Network request failed',\n    isTransient: boolean = true,\n    details?: Record<string, unknown>\n  ) {\n    super(message, 'NETWORK_ERROR', undefined, details);\n    this.name = 'NetworkError';\n    this.isTransient = isTransient;\n  }\n}\n\n/**\n * Server error (500+).\n *\n * Thrown when the server returns an internal error.\n */\nexport class ServerError extends AuthHubError {\n  constructor(\n    message: string = 'Internal server error',\n    statusCode: number = 500,\n    details?: Record<string, unknown>\n  ) {\n    super(message, 'SERVER_ERROR', statusCode, details);\n    this.name = 'ServerError';\n  }\n}\n\n/**\n * Not found error (404).\n *\n * Thrown when the requested resource does not exist.\n */\nexport class NotFoundError extends AuthHubError {\n  /**\n   * The resource type that was not found.\n   */\n  readonly resource: string | undefined;\n\n  constructor(\n    message: string = 'Resource not found',\n    resource?: string,\n    details?: Record<string, unknown>\n  ) {\n    super(message, 'NOT_FOUND', 404, { ...details, resource });\n    this.name = 'NotFoundError';\n    this.resource = resource;\n  }\n}\n\n// ============================================================================\n// AI-Specific Errors\n// ============================================================================\n\n/**\n * Error codes specific to AI operations.\n */\nexport type AIErrorCode =\n  | 'invalid_model'\n  | 'no_provider_configured'\n  | 'provider_unavailable'\n  | 'rate_limit_exceeded'\n  | 'timeout'\n  | 'circuit_open'\n  | 'content_filtered'\n  | 'context_length_exceeded'\n  | 'internal_error';\n\n/**\n * AI-specific error for chat completion failures.\n *\n * Provides detailed error codes and suggestions for common AI operation failures.\n *\n * @example\n * ```typescript\n * try {\n *   await client.ai.chat({ model: 'invalid-model', messages: [] });\n * } catch (error) {\n *   if (error instanceof AIError) {\n *     console.error(`AI Error: ${error.aiCode}`);\n *     console.error(`Model: ${error.model}`);\n *     console.error(`Suggestion: ${error.suggestion}`);\n *     if (error.isRetryable) {\n *       // Implement retry logic\n *     }\n *   }\n * }\n * ```\n */\nexport class AIError extends AuthHubError {\n  /**\n   * AI-specific error code for programmatic handling.\n   */\n  readonly aiCode: AIErrorCode;\n\n  /**\n   * Model ID that caused the error (if applicable).\n   */\n  readonly model: string | undefined;\n\n  constructor(\n    message: string,\n    aiCode: AIErrorCode,\n    statusCode?: number,\n    model?: string\n  ) {\n    super(message, 'AI_ERROR', statusCode, { aiCode, model });\n    this.name = 'AIError';\n    this.aiCode = aiCode;\n    this.model = model;\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, AIError);\n    }\n  }\n\n  /**\n   * Whether this error is likely transient and worth retrying.\n   *\n   * Returns true for rate limits, timeouts, circuit breaker, and provider unavailability.\n   */\n  get isRetryable(): boolean {\n    return [\n      'rate_limit_exceeded',\n      'timeout',\n      'circuit_open',\n      'provider_unavailable',\n    ].includes(this.aiCode);\n  }\n\n  /**\n   * User-friendly suggestion for resolving this error.\n   */\n  get suggestion(): string {\n    switch (this.aiCode) {\n      case 'invalid_model':\n        return 'Use client.ai.listModels() to see available models.';\n      case 'no_provider_configured':\n        return 'Contact your administrator to configure an AI provider in AuthHub.';\n      case 'provider_unavailable':\n        return 'The AI provider is temporarily unavailable. Try again in a few moments.';\n      case 'rate_limit_exceeded':\n        return 'You are being rate limited. Wait and retry with exponential backoff.';\n      case 'circuit_open':\n        return 'Provider circuit breaker is open due to repeated failures. Try later.';\n      case 'timeout':\n        return 'Request timed out. Try a shorter prompt or increase the timeout.';\n      case 'content_filtered':\n        return 'Content was filtered by the model\\'s safety systems. Modify your prompt.';\n      case 'context_length_exceeded':\n        return 'Prompt exceeds model context window. Use a model with larger context or shorten your input.';\n      case 'internal_error':\n      default:\n        return 'An unexpected error occurred. Check AuthHub logs for details.';\n    }\n  }\n\n  /**\n   * Get a human-readable description of this error code.\n   */\n  get description(): string {\n    switch (this.aiCode) {\n      case 'invalid_model':\n        return 'The specified model ID is not recognized or not available.';\n      case 'no_provider_configured':\n        return 'No AI provider is configured for the model type you requested.';\n      case 'provider_unavailable':\n        return 'The AI provider is not responding or has an outage.';\n      case 'rate_limit_exceeded':\n        return 'Too many requests sent to the AI provider.';\n      case 'circuit_open':\n        return 'The provider has been temporarily disabled due to errors.';\n      case 'timeout':\n        return 'The AI request took too long to complete.';\n      case 'content_filtered':\n        return 'The request or response was blocked by content filtering.';\n      case 'context_length_exceeded':\n        return 'The prompt is too long for the selected model.';\n      case 'internal_error':\n      default:\n        return 'An internal error occurred while processing your request.';\n    }\n  }\n}\n\n/**\n * Parse an API error response and return the appropriate error class.\n *\n * @param statusCode - HTTP status code\n * @param body - Error response body\n * @param headers - Response headers\n * @returns Appropriate AuthHubError subclass\n *\n * @internal\n */\nexport function parseApiError(\n  statusCode: number,\n  body: Record<string, unknown>,\n  headers?: Headers\n): AuthHubError {\n  const error = body['error'] as Record<string, unknown> | undefined;\n  const message = (error?.['message'] as string) ?? `Request failed with status ${statusCode}`;\n  const code = (error?.['code'] as string) ?? undefined;\n  const details = (error?.['details'] as Record<string, unknown>) ?? undefined;\n\n  switch (statusCode) {\n    case 400:\n      return new ValidationError(message, undefined, details);\n    case 401:\n      return new AuthError(message, details);\n    case 403:\n      return new AuthError(`Access denied: ${message}`, details);\n    case 404:\n      return new NotFoundError(message, undefined, details);\n    case 429: {\n      const retryAfter = headers?.get('Retry-After');\n      return new RateLimitError(\n        message,\n        retryAfter ? parseInt(retryAfter, 10) : undefined,\n        details\n      );\n    }\n    default:\n      if (statusCode >= 500) {\n        return new ServerError(message, statusCode, details);\n      }\n      return new AuthHubError(message, code ?? 'UNKNOWN_ERROR', statusCode, details);\n  }\n}\n"],"mappings":"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","names":["error","OAuthProvider","state","error","errorDescription"]}