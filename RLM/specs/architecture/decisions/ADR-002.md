# ADR-002: State Persistence Strategy
## Status: Accepted
## Date: 2026-02-14

## Context
The RLM Orchestrator needs to persist the state of the current task (the "Task Ledger") to allow for:
1.  Resuming interrupted tasks.
2.  Auditing the AI's actions.
3.  Providing context to the user.

Options considered:
- **Local JSON File**: Simple, human-readable.
- **SQLite Database**: robust, queryable, transactional.
- **In-Memory**: Fast but not persistent across restarts.

## Decision
We will use a **Local JSON File** (`.rlm/ledger.json`) located in the project root.

## Consequences
- **Pros**:
    - Extremely simple to implement (just `fs.writeFileSync`).
    - Human-readable; easy for developers to inspect and debug.
    - No external dependencies (like sqlite3 bindings).
    - Portable; can be committed to git (if desired, though usually ignored).
- **Cons**:
    - Performance can degrade if the ledger becomes massive (unlikely for typical CLI tasks).
    - Concurrency issues if multiple CLI instances run against the same project (mitigated by file locking if needed).

## Mitigation
We will implement atomic writes to prevent file corruption. If the state complexity grows significantly, we can migrate to SQLite later without changing the external API.
